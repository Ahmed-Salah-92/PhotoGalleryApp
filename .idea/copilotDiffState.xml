<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Photo Gallery App&#10;&#10;[![Platform](https://img.shields.io/badge/platform-Android-green.svg)](http://developer.android.com/index.html)&#10;[![API](https://img.shields.io/badge/API-24%2B-brightgreen.svg)](https://android-arsenal.com/api?level=24)&#10;[![Kotlin](https://img.shields.io/badge/kotlin-1.9.0-blue.svg)](https://kotlinlang.org)&#10;&#10;## Overview&#10;&#10;Photo Gallery App is a modern Android application that displays a curated collection of high-quality photographs from the Pexels API. The app demonstrates best practices in Android development including clean architecture, MVVM pattern, Jetpack components, and offline-first approach.&#10;&#10;![App Screenshot](screenshots/app_screenshot.png)&#10;&#10;## Features&#10;&#10;- Browse curated photos in a beautiful staggered grid layout&#10;- View photo details including photographer information&#10;- Offline support - view previously loaded photos without internet connection&#10;- Pagination with endless scrolling experience&#10;- Smooth loading states with loading indicators&#10;- Robust error handling with user-friendly error messages&#10;- Dark mode support&#10;- Material Design components and animations&#10;&#10;## Architecture&#10;&#10;The app follows Clean Architecture principles and is organized into the following layers:&#10;&#10;- **Presentation Layer**: Contains UI components (activities, fragments), ViewModels, and UI-related classes&#10;- **Domain Layer**: Contains business logic, use cases, and domain models&#10;- **Data Layer**: Responsible for data retrieval and storage, includes repositories and data sources&#10;&#10;### Tech Stack&#10;&#10;- **Kotlin** - Primary development language&#10;- **Coroutines &amp; Flow** - For asynchronous programming&#10;- **Jetpack Components**&#10;  - ViewModel - For UI-related data handling&#10;  - Navigation Component - For fragment navigation&#10;  - Paging 3 - For pagination&#10;  - Room - For local database storage&#10;- **Koin** - For dependency injection&#10;- **Retrofit** - For network requests&#10;- **OkHttp** - For HTTP client with interceptors&#10;- **Glide** - For image loading&#10;- **Material Design Components** - For UI&#10;&#10;## Project Structure&#10;&#10;```&#10;app/&#10;├── src/main/&#10;│   ├── java/com/ragdoll/photogalleryapp/&#10;│   │   ├── data/&#10;│   │   │   ├── local/&#10;│   │   │   │   ├── database/ - Room database and DAOs&#10;│   │   │   │   ├── entity/ - Database entities&#10;│   │   │   │   └── mediator/ - RemoteMediator for Paging&#10;│   │   │   ├── mapper/ - Data mapping classes&#10;│   │   │   ├── remote/&#10;│   │   │   │   ├── api/ - Retrofit API interfaces&#10;│   │   │   │   └── model/ - Network response models&#10;│   │   │   └── repository/ - Repository implementations&#10;│   │   ├── di/ - Dependency injection modules&#10;│   │   ├── domain/&#10;│   │   │   ├── model/ - Domain models&#10;│   │   │   └── repository/ - Repository interfaces&#10;│   │   └── presentation/&#10;│   │       ├── adapter/ - RecyclerView adapters&#10;│   │       ├── common/ - Common UI utilities&#10;│   │       ├── ui/&#10;│   │       │   ├── activity/ - Activities&#10;│   │       │   └── fragment/ - Fragments&#10;│   │       └── viewmodel/ - ViewModels&#10;│   └── res/ - Resources (layouts, drawables, values)&#10;└── build.gradle.kts - App level build file&#10;```&#10;&#10;## Getting Started&#10;&#10;### Prerequisites&#10;&#10;- Android Studio Arctic Fox or later&#10;- Android SDK 33 or higher&#10;- Kotlin 1.9.0 or higher&#10;- JDK 17&#10;&#10;### API Key&#10;&#10;The app uses the [Pexels API](https://www.pexels.com/api/), which requires an API key. To use the app:&#10;&#10;1. Get a free API key from the [Pexels API](https://www.pexels.com/api/new/)&#10;2. Create a file named `secrets.properties` in the root project directory&#10;3. Add your API key to the file: `PEXELS_API_KEY=your_api_key_here`&#10;&#10;### Building and Running&#10;&#10;1. Clone this repository&#10;2. Add the API key as described above&#10;3. Open the project in Android Studio&#10;4. Sync project with Gradle files&#10;5. Run the app on an emulator or physical device&#10;&#10;## Error Handling&#10;&#10;The app implements robust error handling for different scenarios:&#10;&#10;- Network connectivity issues&#10;- API request timeouts&#10;- Server errors&#10;- Empty data sets&#10;&#10;Each error state provides a user-friendly message and a retry option when applicable.&#10;&#10;## Performance Optimizations&#10;&#10;- Resource caching for offline use&#10;- Efficient image loading with Glide&#10;- Pagination to load data as needed&#10;- RemoteMediator for seamless paging from network and local database&#10;- Connection timeouts and retries for network resilience&#10;&#10;## Future Improvements&#10;&#10;- User authentication to save favorite photos&#10;- Search functionality&#10;- Photo filtering by category&#10;- Share photos functionality&#10;- Photo download capability&#10;- UI tests&#10;- Jetpack Compose migration&#10;&#10;## License&#10;&#10;```&#10;MIT License&#10;&#10;Copyright (c) 2025 RagDoll&#10;&#10;Permission is hereby granted, free of charge, to any person obtaining a copy&#10;of this software and associated documentation files (the &quot;Software&quot;), to deal&#10;in the Software without restriction, including without limitation the rights&#10;to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#10;copies of the Software, and to permit persons to whom the Software is&#10;furnished to do so, subject to the following conditions:&#10;&#10;The above copyright notice and this permission notice shall be included in all&#10;copies or substantial portions of the Software.&#10;&#10;THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#10;IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#10;FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE&#10;AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#10;LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#10;OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE&#10;SOFTWARE.&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#10;&#10;import android.util.Log&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import kotlinx.coroutines.flow.first&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class PhotoRemoteMediator(&#10;    private val api: PexelsApi,&#10;    val db: AppDatabase,&#10;    val networkMonitor: NetworkMonitor&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#10;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#10;    val photoDao = db.photoDao()&#10;    val remoteKeysDao = db.remoteKeysDao()&#10;&#10;    override suspend fun initialize(): InitializeAction {&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#10;        return if (isOnline)&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#10;            }&#10;        else&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#10;            }&#10;    }&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#10;    ): MediatorResult {&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#10;&#10;        // Check network connectivity first&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#10;&#10;        if (!isOnline) {&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#10;        }&#10;&#10;        try {&#10;            // Calculate the page number based on the load type&#10;            val page = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#10;                    1&#10;                }&#10;&#10;                LoadType.PREPEND -&gt; {&#10;                    // Get the remote key of the first item in the database&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#10;&#10;                    // If remoteKeys is null or prevPage is null, there's no more data to load at the beginning&#10;                    val prevPage = remoteKeys?.prevPage&#10;                    if (prevPage == null) {&#10;                        Log.d(TAG, &quot;load: PREPEND, no more data at beginning, remoteKeys=$remoteKeys&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;load: PREPEND, loading page $prevPage&quot;)&#10;                    prevPage&#10;                }&#10;&#10;                LoadType.APPEND -&gt; {&#10;                    Log.d(TAG, &quot;load: APPEND request initiated&quot;)&#10;&#10;                    // Get the remote key of the last item in the database&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    Log.d(TAG, &quot;load: APPEND got remoteKeys: $remoteKeys&quot;)&#10;&#10;                    if (remoteKeys == null) {&#10;                        // If there are no keys yet (empty DB), start with page 1&#10;                        // This handles the initial empty database case&#10;                        val nextPageFromEmpty = 1&#10;                        Log.d(TAG, &quot;load: APPEND no remoteKeys found, using default page=$nextPageFromEmpty&quot;)&#10;                        return loadAndSaveData(nextPageFromEmpty, loadType, state)&#10;                    }&#10;&#10;                    val nextPage = remoteKeys.nextPage&#10;                    if (nextPage == null) {&#10;                        Log.d(TAG, &quot;load: APPEND nextPage is null, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#10;                    nextPage&#10;                }&#10;            }&#10;&#10;            return loadAndSaveData(page, loadType, state)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#10;            return MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun loadAndSaveData(page: Int, loadType: LoadType, state: PagingState&lt;Int, PhotoEntity&gt;): MediatorResult {&#10;        try {&#10;            // Fetch data from the API with proper page size&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#10;            Log.d(TAG, &quot;loadAndSaveData: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#10;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#10;            Log.d(TAG, &quot;loadAndSaveData: API response received, photos count: ${response.photos.size}&quot;)&#10;&#10;            if (response.photos.isNotEmpty()) {&#10;                Log.d(TAG, &quot;loadAndSaveData: First photo in response: id=${response.photos.first().id}&quot;)&#10;                Log.d(TAG, &quot;loadAndSaveData: Last photo in response: id=${response.photos.last().id}&quot;)&#10;            }&#10;&#10;            // Calculate whether we've reached the end of pagination&#10;            val endOfPaginationReached = response.photos.isEmpty()&#10;&#10;            // Calculate next and previous page numbers&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#10;&#10;            // Handle database transaction&#10;            Log.d(TAG, &quot;loadAndSaveData: Starting database transaction&quot;)&#10;            db.withTransaction {&#10;                // If refreshing, clear the existing data&#10;                if (loadType == LoadType.REFRESH) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: REFRESH mode, clearing existing data&quot;)&#10;                    remoteKeysDao.clearRemoteKeys()&#10;                    photoDao.clearAll()&#10;                }&#10;&#10;                // Convert API responses to entities&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#10;                Log.d(TAG, &quot;loadAndSaveData: Converted ${photoEntities.size} API responses to entities&quot;)&#10;&#10;                // Create and insert remote keys&#10;                val keys = photoEntities.map { photo -&gt;&#10;                    RemoteKeys(&#10;                        photoId = photo.id,&#10;                        prevPage = prevPage,&#10;                        currentPage = page,&#10;                        nextPage = nextPage&#10;                    )&#10;                }&#10;&#10;                // Insert keys and photos&#10;                if (keys.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${keys.size} remote keys into database&quot;)&#10;                    remoteKeysDao.insertAll(keys)&#10;                }&#10;&#10;                if (photoEntities.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${photoEntities.size} photos into database&quot;)&#10;                    photoDao.insertALll(photoEntities)&#10;                    Log.d(TAG, &quot;loadAndSaveData: Successfully inserted photos into database&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;loadAndSaveData: No photos to insert into database&quot;)&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;loadAndSaveData: End of pagination reached: $endOfPaginationReached&quot;)&#10;            return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;loadAndSaveData: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;loadAndSaveData: Error message: ${e.message}&quot;)&#10;            return MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForFirstItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the first page with data&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#10;            ?.let { photo -&gt;&#10;                remoteKeysDao.getRemoteKeysById(photo.id)&#10;            }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the last page with data&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#10;&#10;        // Get the last item from that page&#10;        val lastItem = lastPage?.data?.lastOrNull()&#10;&#10;        // Return the remote keys associated with that item&#10;        return lastItem?.let { photo -&gt;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // The paging library is trying to load data after the anchor position&#10;        // Get the item closest to the anchor position&#10;        return state.anchorPosition?.let { position -&gt;&#10;            state.closestItemToPosition(position)?.id?.let { id -&gt;&#10;                remoteKeysDao.getRemoteKeysById(id)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import androidx.paging.ExperimentalPagingApi&#13;&#10;import androidx.paging.LoadType&#13;&#10;import androidx.paging.PagingState&#13;&#10;import androidx.paging.RemoteMediator&#13;&#10;import androidx.room.withTransaction&#13;&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#13;&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#13;&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#13;&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#13;&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#13;&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#13;&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#13;&#10;import kotlinx.coroutines.flow.first&#13;&#10;&#13;&#10;@OptIn(ExperimentalPagingApi::class)&#13;&#10;class PhotoRemoteMediator(&#13;&#10;    private val api: PexelsApi,&#13;&#10;    val db: AppDatabase,&#13;&#10;    val networkMonitor: NetworkMonitor&#13;&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#13;&#10;&#13;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#13;&#10;    val photoDao = db.photoDao()&#13;&#10;    val remoteKeysDao = db.remoteKeysDao()&#13;&#10;&#13;&#10;    override suspend fun initialize(): InitializeAction {&#13;&#10;        val isOnline = networkMonitor.isOnline.first()&#13;&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#13;&#10;        return if (isOnline)&#13;&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#13;&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#13;&#10;            }&#13;&#10;        else&#13;&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#13;&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun load(&#13;&#10;        loadType: LoadType,&#13;&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#13;&#10;    ): MediatorResult {&#13;&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#13;&#10;&#13;&#10;        // Check network connectivity first&#13;&#10;        val isOnline = networkMonitor.isOnline.first()&#13;&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#13;&#10;&#13;&#10;        if (!isOnline) {&#13;&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#13;&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#13;&#10;        }&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Calculate the page number based on the load type&#13;&#10;            val page = when (loadType) {&#13;&#10;                LoadType.REFRESH -&gt; {&#13;&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#13;&#10;                    1&#13;&#10;                }&#13;&#10;&#13;&#10;                LoadType.PREPEND -&gt; {&#13;&#10;                    // Get the remote key of the first item in the database&#13;&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#13;&#10;&#13;&#10;                    // If remoteKeys is null or prevPage is null, there's no more data to load at the beginning&#13;&#10;                    val prevPage = remoteKeys?.prevPage&#13;&#10;                    if (prevPage == null) {&#13;&#10;                        Log.d(TAG, &quot;load: PREPEND, no more data at beginning, remoteKeys=$remoteKeys&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;load: PREPEND, loading page $prevPage&quot;)&#13;&#10;                    prevPage&#13;&#10;                }&#13;&#10;&#13;&#10;                LoadType.APPEND -&gt; {&#13;&#10;                    Log.d(TAG, &quot;load: APPEND request initiated&quot;)&#13;&#10;&#13;&#10;                    // Get the remote key of the last item in the database&#13;&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#13;&#10;                    Log.d(TAG, &quot;load: APPEND got remoteKeys: $remoteKeys&quot;)&#13;&#10;&#13;&#10;                    if (remoteKeys == null) {&#13;&#10;                        // If there are no keys yet (empty DB), start with page 1&#13;&#10;                        // This handles the initial empty database case&#13;&#10;                        val nextPageFromEmpty = 1&#13;&#10;                        Log.d(TAG, &quot;load: APPEND no remoteKeys found, using default page=$nextPageFromEmpty&quot;)&#13;&#10;                        return loadAndSaveData(nextPageFromEmpty, loadType, state)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    val nextPage = remoteKeys.nextPage&#13;&#10;                    if (nextPage == null) {&#13;&#10;                        Log.d(TAG, &quot;load: APPEND nextPage is null, we've reached the end&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Check if we've already loaded this page to prevent duplicate loads&#13;&#10;                    val lastLoadedPage = remoteKeys.currentPage&#13;&#10;                    if (nextPage == lastLoadedPage) {&#13;&#10;                        Log.d(TAG, &quot;load: APPEND skipping duplicate load of page $nextPage&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = false)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#13;&#10;                    nextPage&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            return loadAndSaveData(page, loadType, state)&#13;&#10;&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#13;&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#13;&#10;            return MediatorResult.Error(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun loadAndSaveData(page: Int, loadType: LoadType, state: PagingState&lt;Int, PhotoEntity&gt;): MediatorResult {&#13;&#10;        try {&#13;&#10;            // Fetch data from the API with proper page size&#13;&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#13;&#10;&#13;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: API response received, photos count: ${response.photos.size}&quot;)&#13;&#10;&#13;&#10;            if (response.photos.isNotEmpty()) {&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: First photo in response: id=${response.photos.first().id}&quot;)&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: Last photo in response: id=${response.photos.last().id}&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            // Calculate whether we've reached the end of pagination&#13;&#10;            val endOfPaginationReached = response.photos.isEmpty()&#13;&#10;&#13;&#10;            // Calculate next and previous page numbers&#13;&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#13;&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#13;&#10;&#13;&#10;            // Handle database transaction&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: Starting database transaction&quot;)&#13;&#10;            db.withTransaction {&#13;&#10;                // If refreshing, clear the existing data&#13;&#10;                if (loadType == LoadType.REFRESH) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: REFRESH mode, clearing existing data&quot;)&#13;&#10;                    remoteKeysDao.clearRemoteKeys()&#13;&#10;                    photoDao.clearAll()&#13;&#10;                }&#13;&#10;&#13;&#10;                // Convert API responses to entities&#13;&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: Converted ${photoEntities.size} API responses to entities&quot;)&#13;&#10;&#13;&#10;                // Create and insert remote keys&#13;&#10;                val keys = photoEntities.map { photo -&gt;&#13;&#10;                    RemoteKeys(&#13;&#10;                        photoId = photo.id,&#13;&#10;                        prevPage = prevPage,&#13;&#10;                        currentPage = page,&#13;&#10;                        nextPage = nextPage&#13;&#10;                    )&#13;&#10;                }&#13;&#10;&#13;&#10;                // Insert keys and photos&#13;&#10;                if (keys.isNotEmpty()) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${keys.size} remote keys into database&quot;)&#13;&#10;                    remoteKeysDao.insertAll(keys)&#13;&#10;                }&#13;&#10;&#13;&#10;                if (photoEntities.isNotEmpty()) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${photoEntities.size} photos into database&quot;)&#13;&#10;                    photoDao.insertALll(photoEntities)&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Successfully inserted photos into database&quot;)&#13;&#10;                } else {&#13;&#10;                    Log.w(TAG, &quot;loadAndSaveData: No photos to insert into database&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: End of pagination reached: $endOfPaginationReached&quot;)&#13;&#10;            return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;loadAndSaveData: Error loading data&quot;, e)&#13;&#10;            Log.e(TAG, &quot;loadAndSaveData: Error message: ${e.message}&quot;)&#13;&#10;            return MediatorResult.Error(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyForFirstItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // Get the first page with data&#13;&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#13;&#10;            ?.let { photo -&gt;&#13;&#10;                remoteKeysDao.getRemoteKeysById(photo.id)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // Get the last page with data&#13;&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#13;&#10;&#13;&#10;        // Get the last item from that page&#13;&#10;        val lastItem = lastPage?.data?.lastOrNull()&#13;&#10;&#13;&#10;        // Return the remote keys associated with that item&#13;&#10;        return lastItem?.let { photo -&gt;&#13;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // The paging library is trying to load data after the anchor position&#13;&#10;        // Get the item closest to the anchor position&#13;&#10;        return state.anchorPosition?.let { position -&gt;&#13;&#10;            state.closestItemToPosition(position)?.id?.let { id -&gt;&#13;&#10;                remoteKeysDao.getRemoteKeysById(id)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/di/NetworkModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/di/NetworkModule.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.di&#10;&#10;import com.ragdoll.photogalleryapp.BuildConfig&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi.Companion.BASE_URL&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import org.koin.dsl.module&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;&#10;/**&#10; * Network module that provides networking related dependencies&#10; */&#10;val networkModule = module {&#10;    // OkHttpClient with logging&#10;    single {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = if (BuildConfig.DEBUG)&#10;                HttpLoggingInterceptor.Level.BODY&#10;            else&#10;                HttpLoggingInterceptor.Level.NONE&#10;        }&#10;&#10;        OkHttpClient.Builder()&#10;            .addInterceptor(loggingInterceptor)&#10;            .addInterceptor { chain -&gt;&#10;                // Add API key to requests if needed&#10;                val originalRequest = chain.request()&#10;                val requestBuilder = originalRequest.newBuilder()&#10;                    .header(&quot;Authorization&quot;, BuildConfig.PEXELS_API_KEY)&#10;                    .method(originalRequest.method, originalRequest.body)&#10;&#10;                chain.proceed(requestBuilder.build())&#10;            }&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    // Retrofit instance&#10;    single {&#10;        Retrofit.Builder()&#10;            .baseUrl(BASE_URL) // Replace with your base URL&#10;            .client(get())&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    // API Services&#10;    // Example: single { get&lt;Retrofit&gt;().create(YourApiService::class.java) }&#10;    single { get&lt;Retrofit&gt;().create(PexelsApi::class.java) }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.di&#13;&#10;&#13;&#10;import com.ragdoll.photogalleryapp.BuildConfig&#13;&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#13;&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi.Companion.BASE_URL&#13;&#10;import okhttp3.OkHttpClient&#13;&#10;import okhttp3.Interceptor&#13;&#10;import okhttp3.logging.HttpLoggingInterceptor&#13;&#10;import org.koin.dsl.module&#13;&#10;import retrofit2.Retrofit&#13;&#10;import retrofit2.converter.gson.GsonConverterFactory&#13;&#10;import java.util.concurrent.TimeUnit&#13;&#10;&#13;&#10;/**&#13;&#10; * Network module that provides networking related dependencies&#13;&#10; */&#13;&#10;val networkModule = module {&#13;&#10;    // OkHttpClient with logging&#13;&#10;    single {&#13;&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#13;&#10;            level = if (BuildConfig.DEBUG)&#13;&#10;                HttpLoggingInterceptor.Level.BODY&#13;&#10;            else&#13;&#10;                HttpLoggingInterceptor.Level.NONE&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create a retry interceptor&#13;&#10;        val retryInterceptor = Interceptor { chain -&gt;&#13;&#10;            val request = chain.request()&#13;&#10;            var response = chain.proceed(request)&#13;&#10;            var tryCount = 0&#13;&#10;            val maxRetry = 2 // Maximum number of retries&#13;&#10;&#13;&#10;            while (!response.isSuccessful &amp;&amp; tryCount &lt; maxRetry) {&#13;&#10;                tryCount++&#13;&#10;                // Wait before retrying (exponential backoff)&#13;&#10;                Thread.sleep(1000L * tryCount)&#13;&#10;                response.close()&#13;&#10;                response = chain.proceed(request)&#13;&#10;            }&#13;&#10;&#13;&#10;            response&#13;&#10;        }&#13;&#10;&#13;&#10;        OkHttpClient.Builder()&#13;&#10;            .addInterceptor(loggingInterceptor)&#13;&#10;            .addInterceptor(retryInterceptor)&#13;&#10;            .addInterceptor { chain -&gt;&#13;&#10;                // Add API key to requests if needed&#13;&#10;                val originalRequest = chain.request()&#13;&#10;                val requestBuilder = originalRequest.newBuilder()&#13;&#10;                    .header(&quot;Authorization&quot;, BuildConfig.PEXELS_API_KEY)&#13;&#10;                    .method(originalRequest.method, originalRequest.body)&#13;&#10;&#13;&#10;                chain.proceed(requestBuilder.build())&#13;&#10;            }&#13;&#10;            .connectTimeout(10, TimeUnit.SECONDS) // Reduced from 30 to 10 seconds&#13;&#10;            .readTimeout(10, TimeUnit.SECONDS)    // Reduced from 30 to 10 seconds&#13;&#10;            .writeTimeout(10, TimeUnit.SECONDS)   // Added write timeout&#13;&#10;            .retryOnConnectionFailure(true)       // Enable retries on connection failures&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    // Retrofit instance&#13;&#10;    single {&#13;&#10;        Retrofit.Builder()&#13;&#10;            .baseUrl(BASE_URL) // Replace with your base URL&#13;&#10;            .client(get())&#13;&#10;            .addConverterFactory(GsonConverterFactory.create())&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    // API Services&#13;&#10;    // Example: single { get&lt;Retrofit&gt;().create(YourApiService::class.java) }&#13;&#10;    single { get&lt;Retrofit&gt;().create(PexelsApi::class.java) }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/presentation/ui/fragment/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/presentation/ui/fragment/HomeFragment.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.presentation.ui.fragment&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.paging.LoadState&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager&#10;import com.ragdoll.photogalleryapp.R&#10;import com.ragdoll.photogalleryapp.databinding.FragmentHomeBinding&#10;import com.ragdoll.photogalleryapp.presentation.adapter.PhotoAdapter&#10;import com.ragdoll.photogalleryapp.presentation.ui.activity.MainActivity&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.distinctUntilChanged&#10;import kotlinx.coroutines.launch&#10;&#10;// 8 paging&#10;class HomeFragment : Fragment() {&#10;    private lateinit var binding: FragmentHomeBinding&#10;    private lateinit var viewModel: PhotosViewModel&#10;    private val photoAdapter = PhotoAdapter()&#10;    private val TAG = &quot;HomeFragment&quot;&#10;&#10;    // Track the previous network state to detect changes&#10;    private var previousNetworkState = false&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        viewModel = (activity as MainActivity).viewModel&#10;        Log.d(TAG, &quot;onViewCreated: ViewModel initialized&quot;)&#10;&#10;        initRecyclerView()&#10;        observeLoadStates() // Add load state observer&#10;        observePhotos()&#10;        observeNetworkState()&#10;        setupPhotoClickListener()&#10;&#10;        // Initially show loading, but this will be controlled by the load state observer&#10;        binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun initRecyclerView() = binding.photosRV.apply {&#10;        adapter = photoAdapter&#10;        layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        Log.d(TAG, &quot;initRecyclerView: RecyclerView initialized with adapter&quot;)&#10;    }&#10;&#10;    // Add a new function to observe adapter load states&#10;    private fun observeLoadStates() {&#10;        lifecycleScope.launch {&#10;            photoAdapter.loadStateFlow&#10;                .distinctUntilChanged()&#10;                .collect { loadStates -&gt;&#10;                    Log.d(TAG, &quot;observeLoadStates: Load state changed: ${loadStates.refresh}&quot;)&#10;&#10;                    // Handle loading state&#10;                    when (loadStates.refresh) {&#10;                        is LoadState.Loading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;                        }&#10;                        is LoadState.Error -&gt; {&#10;                            val error = (loadStates.refresh as LoadState.Error).error&#10;                            Log.e(TAG, &quot;observeLoadStates: Error loading data&quot;, error)&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;                            if (!viewModel.isOnline.value) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_internet_connection)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                                binding.photosRV.visibility = View.GONE&#10;                            }&#10;                        }&#10;                        is LoadState.NotLoading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;                            if (photoAdapter.itemCount == 0) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_photos_available)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                            } else {&#10;                                binding.noPhotosTv.visibility = View.GONE&#10;                                binding.photosRV.visibility = View.VISIBLE&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun observePhotos() {&#10;        Log.d(TAG, &quot;observePhotos: Starting to observe photos flow&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.photos.collectLatest { pagingData -&gt;&#10;                Log.d(TAG, &quot;observePhotos: Received paging data&quot;)&#10;                photoAdapter.submitData(pagingData)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeNetworkState() {&#10;        Log.d(TAG, &quot;observeNetworkState: Starting to observe network state&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.isOnline.collect { isOnline -&gt;&#10;                Log.d(TAG, &quot;observeNetworkState: Network state changed, isOnline = $isOnline&quot;)&#10;&#10;                // Handle the case when network becomes available (was offline, now online)&#10;                val networkBecameAvailable = !previousNetworkState &amp;&amp; isOnline&#10;                previousNetworkState = isOnline&#10;&#10;                if (!isOnline &amp;&amp; photoAdapter.itemCount == 0) {&#10;                    binding.noPhotosTv.apply {&#10;                        text = getString(R.string.no_internet_connection)&#10;                        visibility = View.VISIBLE&#10;                    }&#10;                    binding.photosRV.visibility = View.GONE&#10;                } else if (isOnline) {&#10;                    binding.noPhotosTv.visibility = View.GONE&#10;                    binding.photosRV.visibility = View.VISIBLE&#10;&#10;                    // If network just became available, trigger a refresh&#10;                    if (networkBecameAvailable) {&#10;                        Log.d(TAG, &quot;observeNetworkState: Network became available, refreshing data&quot;)&#10;                        photoAdapter.refresh()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupPhotoClickListener() {&#10;        photoAdapter.setOnItemClickListener { photo -&gt;&#10;            // Ensure loading indicator is hidden before navigation&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;            val bundle = Bundle().apply {&#10;                putString(&quot;photo_photographer&quot;, photo.photographer)&#10;                putString(&quot;photo_original_url&quot;, photo.src.original)&#10;                putString(&quot;photo_alt&quot;, photo.alt)&#10;            }&#10;            findNavController().navigate(&#10;                R.id.action_homeFragment_to_detailsFragment, bundle&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Ensure loading indicator is hidden when fragment is destroyed&#10;        if (::binding.isInitialized) {&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.presentation.ui.fragment&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.paging.LoadState&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager&#10;import com.ragdoll.photogalleryapp.R&#10;import com.ragdoll.photogalleryapp.databinding.FragmentHomeBinding&#10;import com.ragdoll.photogalleryapp.presentation.adapter.PhotoAdapter&#10;import com.ragdoll.photogalleryapp.presentation.ui.activity.MainActivity&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.distinctUntilChanged&#10;import kotlinx.coroutines.launch&#10;&#10;// 8 paging&#10;class HomeFragment : Fragment() {&#10;    private lateinit var binding: FragmentHomeBinding&#10;    private lateinit var viewModel: PhotosViewModel&#10;    private val photoAdapter = PhotoAdapter()&#10;    private val TAG = &quot;HomeFragment&quot;&#10;&#10;    // Track the previous network state to detect changes&#10;    private var previousNetworkState = false&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        viewModel = (activity as MainActivity).viewModel&#10;        Log.d(TAG, &quot;onViewCreated: ViewModel initialized&quot;)&#10;&#10;        initRecyclerView()&#10;        observeLoadStates() // Add load state observer&#10;        observePhotos()&#10;        observeNetworkState()&#10;        setupPhotoClickListener()&#10;&#10;        // Initially show loading, but this will be controlled by the load state observer&#10;        binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun initRecyclerView() = binding.photosRV.apply {&#10;        adapter = photoAdapter&#10;        layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        Log.d(TAG, &quot;initRecyclerView: RecyclerView initialized with adapter&quot;)&#10;    }&#10;&#10;    // Add a new function to observe adapter load states&#10;    private fun observeLoadStates() {&#10;        lifecycleScope.launch {&#10;            photoAdapter.loadStateFlow&#10;                .distinctUntilChanged()&#10;                .collect { loadStates -&gt;&#10;                    Log.d(TAG, &quot;observeLoadStates: Load state changed: ${loadStates.refresh}&quot;)&#10;&#10;                    // Handle loading state&#10;                    when (loadStates.refresh) {&#10;                        is LoadState.Loading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;                            binding.errorLayout.visibility = View.GONE&#10;                        }&#10;                        is LoadState.Error -&gt; {&#10;                            val error = (loadStates.refresh as LoadState.Error).error&#10;                            Log.e(TAG, &quot;observeLoadStates: Error loading data&quot;, error)&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;                            &#10;                            // Show appropriate error message based on error type&#10;                            if (!viewModel.isOnline.value) {&#10;                                showErrorView(&#10;                                    getString(R.string.no_internet_connection), &#10;                                    getString(R.string.check_connection_and_try_again)&#10;                                )&#10;                            } else {&#10;                                when (error) {&#10;                                    is java.net.SocketTimeoutException -&gt; {&#10;                                        showErrorView(&#10;                                            getString(R.string.connection_timeout),&#10;                                            getString(R.string.server_taking_too_long)&#10;                                        )&#10;                                    }&#10;                                    is java.io.IOException -&gt; {&#10;                                        showErrorView(&#10;                                            getString(R.string.network_error),&#10;                                            getString(R.string.could_not_connect_to_server)&#10;                                        )&#10;                                    }&#10;                                    else -&gt; {&#10;                                        showErrorView(&#10;                                            getString(R.string.unknown_error),&#10;                                            error.message ?: getString(R.string.something_went_wrong)&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        is LoadState.NotLoading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;                            binding.errorLayout.visibility = View.GONE&#10;                            &#10;                            if (photoAdapter.itemCount == 0) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_photos_available)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                            } else {&#10;                                binding.noPhotosTv.visibility = View.GONE&#10;                                binding.photosRV.visibility = View.VISIBLE&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun showErrorView(title: String, message: String) {&#10;        binding.apply {&#10;            errorTitle.text = title&#10;            errorMessage.text = message&#10;            errorLayout.visibility = View.VISIBLE&#10;            photosRV.visibility = if (photoAdapter.itemCount == 0) View.GONE else View.VISIBLE&#10;            retryButton.setOnClickListener { &#10;                errorLayout.visibility = View.GONE&#10;                loadingProgressIndicator.visibility = View.VISIBLE&#10;                photoAdapter.refresh() &#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observePhotos() {&#10;        Log.d(TAG, &quot;observePhotos: Starting to observe photos flow&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.photos.collectLatest { pagingData -&gt;&#10;                Log.d(TAG, &quot;observePhotos: Received paging data&quot;)&#10;                photoAdapter.submitData(pagingData)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeNetworkState() {&#10;        Log.d(TAG, &quot;observeNetworkState: Starting to observe network state&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.isOnline.collect { isOnline -&gt;&#10;                Log.d(TAG, &quot;observeNetworkState: Network state changed, isOnline = $isOnline&quot;)&#10;&#10;                // Handle the case when network becomes available (was offline, now online)&#10;                val networkBecameAvailable = !previousNetworkState &amp;&amp; isOnline&#10;                previousNetworkState = isOnline&#10;&#10;                if (!isOnline &amp;&amp; photoAdapter.itemCount == 0) {&#10;                    binding.noPhotosTv.apply {&#10;                        text = getString(R.string.no_internet_connection)&#10;                        visibility = View.VISIBLE&#10;                    }&#10;                    binding.photosRV.visibility = View.GONE&#10;                } else if (isOnline) {&#10;                    binding.noPhotosTv.visibility = View.GONE&#10;                    binding.photosRV.visibility = View.VISIBLE&#10;&#10;                    // If network just became available, trigger a refresh&#10;                    if (networkBecameAvailable) {&#10;                        Log.d(TAG, &quot;observeNetworkState: Network became available, refreshing data&quot;)&#10;                        photoAdapter.refresh()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupPhotoClickListener() {&#10;        photoAdapter.setOnItemClickListener { photo -&gt;&#10;            // Ensure loading indicator is hidden before navigation&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;            val bundle = Bundle().apply {&#10;                putString(&quot;photo_photographer&quot;, photo.photographer)&#10;                putString(&quot;photo_original_url&quot;, photo.src.original)&#10;                putString(&quot;photo_alt&quot;, photo.alt)&#10;            }&#10;            findNavController().navigate(&#10;                R.id.action_homeFragment_to_detailsFragment, bundle&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Ensure loading indicator is hidden when fragment is destroyed&#10;        if (::binding.isInitialized) {&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/fragment_home.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:layout_margin=&quot;10dp&quot;&#10;    tools:context=&quot;.presentation.ui.fragment.HomeFragment&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/photos_RV&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        tools:layoutManager=&quot;androidx.recyclerview.widget.StaggeredGridLayoutManager&quot;&#10;        tools:listitem=&quot;@layout/item_list&quot;&#10;        tools:spanCount=&quot;2&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.progressindicator.CircularProgressIndicator&#10;        android:id=&quot;@+id/loading_progress_indicator&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:indeterminate=&quot;true&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:indicatorSize=&quot;48dp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:trackThickness=&quot;8dp&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/no_photos_tv&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        tools:text=&quot;No photos found&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:layout_margin=&quot;10dp&quot;&#10;    tools:context=&quot;.presentation.ui.fragment.HomeFragment&quot;&gt;&#10;&#10;    &lt;androidx.recyclerview.widget.RecyclerView&#10;        android:id=&quot;@+id/photos_RV&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:clipToPadding=&quot;false&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        tools:layoutManager=&quot;androidx.recyclerview.widget.StaggeredGridLayoutManager&quot;&#10;        tools:listitem=&quot;@layout/item_list&quot;&#10;        tools:spanCount=&quot;2&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;com.google.android.material.progressindicator.CircularProgressIndicator&#10;        android:id=&quot;@+id/loading_progress_indicator&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:indeterminate=&quot;true&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:indicatorSize=&quot;48dp&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        app:trackThickness=&quot;8dp&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/no_photos_tv&quot;&#10;        android:layout_width=&quot;wrap_content&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:textSize=&quot;24sp&quot;&#10;        android:visibility=&quot;invisible&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        tools:text=&quot;No photos found&quot;&#10;        tools:visibility=&quot;visible&quot; /&gt;&#10;&#10;    &lt;!-- Error layout that shows more detailed error messages and a retry button --&gt;&#10;    &lt;androidx.constraintlayout.widget.ConstraintLayout&#10;        android:id=&quot;@+id/error_layout&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:visibility=&quot;gone&quot;&#10;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;&#10;        app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;        app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;        app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;        tools:visibility=&quot;visible&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/error_icon&quot;&#10;            android:layout_width=&quot;64dp&quot;&#10;            android:layout_height=&quot;64dp&quot;&#10;            android:contentDescription=&quot;@string/error_icon&quot;&#10;            android:src=&quot;@android:drawable/stat_notify_error&quot;&#10;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;            app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;            app:layout_constraintTop_toTopOf=&quot;parent&quot;&#10;            app:tint=&quot;@android:color/darker_gray&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/error_title&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;16dp&quot;&#10;            android:textAlignment=&quot;center&quot;&#10;            android:textSize=&quot;20sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;            app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;            app:layout_constraintTop_toBottomOf=&quot;@+id/error_icon&quot;&#10;            tools:text=&quot;Connection timeout&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/error_message&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginStart=&quot;24dp&quot;&#10;            android:layout_marginTop=&quot;8dp&quot;&#10;            android:layout_marginEnd=&quot;24dp&quot;&#10;            android:textAlignment=&quot;center&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;            app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;            app:layout_constraintTop_toBottomOf=&quot;@+id/error_title&quot;&#10;            tools:text=&quot;The server is taking too long to respond. Please try again.&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/retry_button&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_marginTop=&quot;24dp&quot;&#10;            android:text=&quot;@string/retry&quot;&#10;            app:layout_constraintEnd_toEndOf=&quot;parent&quot;&#10;            app:layout_constraintStart_toStartOf=&quot;parent&quot;&#10;            app:layout_constraintTop_toBottomOf=&quot;@+id/error_message&quot; /&gt;&#10;&#10;    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;&#10;&#10;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/values/strings.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/values/strings.xml" />
              <option name="originalContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Photo Gallery App&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;an_error_occurred&quot;&gt;&quot;An error occurred: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;no_internet_connection&quot;&gt;No Internet Connection&lt;/string&gt;&#10;    &lt;string name=&quot;hello_blank_fragment&quot;&gt;Hello blank fragment&lt;/string&gt;&#10;    &lt;string name=&quot;photo_image&quot;&gt;Photo Image&lt;/string&gt;&#10;    &lt;string name=&quot;unknown_error&quot;&gt;Unknown error&lt;/string&gt;&#10;    &lt;string name=&quot;error&quot;&gt;error: &lt;/string&gt;&#10;    &lt;string name=&quot;no_photos_found&quot;&gt;No Photos Are Found !&lt;/string&gt;&#10;    &lt;string name=&quot;no_description_available&quot;&gt;No Description Available&lt;/string&gt;&#10;    &lt;string name=&quot;go_to_website&quot;&gt;Go To Website&lt;/string&gt;&#10;    &lt;string name=&quot;go_to_photographer_profile&quot;&gt;Go to Photographer Profile&lt;/string&gt;&#10;    &lt;string name=&quot;network_error&quot;&gt;&quot;Network Error: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;server_error&quot;&gt;&quot;Server Error: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;unexpected_error&quot;&gt;&quot;Unexpected Error: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;no_photos_available&quot;&gt;No Photos Available&lt;/string&gt;&#10;&lt;/resources&gt;" />
              <option name="updatedContent" value="&lt;resources&gt;&#10;    &lt;string name=&quot;app_name&quot;&gt;Photo Gallery App&lt;/string&gt;&#10;&#10;    &lt;string name=&quot;an_error_occurred&quot;&gt;&quot;An error occurred: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;no_internet_connection&quot;&gt;No Internet Connection&lt;/string&gt;&#10;    &lt;string name=&quot;hello_blank_fragment&quot;&gt;Hello blank fragment&lt;/string&gt;&#10;    &lt;string name=&quot;photo_image&quot;&gt;Photo Image&lt;/string&gt;&#10;    &lt;string name=&quot;unknown_error&quot;&gt;Unknown error&lt;/string&gt;&#10;    &lt;string name=&quot;error&quot;&gt;error: &lt;/string&gt;&#10;    &lt;string name=&quot;no_photos_found&quot;&gt;No Photos Are Found !&lt;/string&gt;&#10;    &lt;string name=&quot;no_description_available&quot;&gt;No Description Available&lt;/string&gt;&#10;    &lt;string name=&quot;go_to_website&quot;&gt;Go To Website&lt;/string&gt;&#10;    &lt;string name=&quot;go_to_photographer_profile&quot;&gt;Go to Photographer Profile&lt;/string&gt;&#10;    &lt;string name=&quot;network_error&quot;&gt;Network Error&lt;/string&gt;&#10;    &lt;string name=&quot;server_error&quot;&gt;&quot;Server Error: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;unexpected_error&quot;&gt;&quot;Unexpected Error: &quot;&lt;/string&gt;&#10;    &lt;string name=&quot;no_photos_available&quot;&gt;No Photos Available&lt;/string&gt;&#10;    &#10;    &lt;!-- New strings for improved error handling --&gt;&#10;    &lt;string name=&quot;retry&quot;&gt;Try Again&lt;/string&gt;&#10;    &lt;string name=&quot;connection_timeout&quot;&gt;Connection Timeout&lt;/string&gt;&#10;    &lt;string name=&quot;server_taking_too_long&quot;&gt;The server is taking too long to respond. Please try again.&lt;/string&gt;&#10;    &lt;string name=&quot;could_not_connect_to_server&quot;&gt;Could not connect to the server. Please check your internet connection and try again.&lt;/string&gt;&#10;    &lt;string name=&quot;check_connection_and_try_again&quot;&gt;Please check your internet connection and try again.&lt;/string&gt;&#10;    &lt;string name=&quot;something_went_wrong&quot;&gt;Something went wrong. Please try again later.&lt;/string&gt;&#10;    &lt;string name=&quot;error_icon&quot;&gt;Error icon&lt;/string&gt;&#10;&lt;/resources&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>