<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    // Kotlin Kapt plugin&#10;    id(&quot;kotlin-kapt&quot;)&#10;    // Kotlin Symbol Processing plugin&#10;    id(&quot;com.google.devtools.ksp&quot;)&#10;    // Safe args plugin Kotlin-Only&#10;    id(&quot;androidx.navigation.safeargs.kotlin&quot;)&#10;}&#10;&#10;// Load secrets.properties file&#10;val secretPropertiesFile = rootProject.file(&quot;secrets.properties&quot;) // Fixed path to the correct location&#10;val secretsProperties = Properties()&#10;if (secretPropertiesFile.exists())&#10;    secretsProperties.load(secretPropertiesFile.inputStream())&#10;else    // If the secrets.properties file does not exist, log a warning&#10;    println(&quot;Warning!!: secrets.properties file not found. Using empty properties.&quot;)&#10;&#10;android {&#10;    namespace = &quot;com.ragdoll.photogalleryapp&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.ragdoll.photogalleryapp&quot;&#10;        minSdk = 26&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Access the property&#10;        val pexelsApiKey = secretsProperties.getProperty(&quot;PEXELS_API_KEY&quot;)&#10;            ?: &quot;&quot; // Default to empty string if not found&#10;        buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKey\&quot;&quot;)&#10;&#10;    }&#10;&#10;    buildTypes {&#10;        debug {&#10;            // Debug-specific configurations&#10;            // You can also define it per build type if needed&#10;            // val pexelsApiKeyDebug = secretsProperties.getProperty(&quot;PEXELS_API_KEY_DEBUG&quot;) ?: pexelsApiKey&#10;            // resValue(&quot;string&quot;, &quot;pexels_api_key&quot;, &quot;\&quot;$pexelsApiKeyDebug\&quot;&quot;) // Using resValue&#10;            // buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKeyDebug\&quot;&quot;)  // Using buildConfigField&#10;        }&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            // For release, you might also want to ensure the API key is set&#10;            // val pexelsApiKeyRelease = secretsProperties.getProperty(&quot;PEXELS_API_KEY_RELEASE&quot;) ?: pexelsApiKey&#10;            // buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKeyRelease\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;&#10;    buildFeatures {&#10;        viewBinding = true&#10;        dataBinding = true&#10;        buildConfig = true&#10;    }&#10;&#10;}&#10;&#10;dependencies {&#10;    // Core&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.appcompat)&#10;    implementation(libs.material)&#10;    implementation(libs.androidx.activity)&#10;    implementation(libs.androidx.constraintlayout)&#10;&#10;    // Lifecycle &amp; ViewModel&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.8.7&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.8.7&quot;)&#10;&#10;    // Navigation&#10;    implementation(&quot;androidx.navigation:navigation-fragment-ktx:2.9.0&quot;)&#10;    implementation(&quot;androidx.navigation:navigation-ui-ktx:2.9.0&quot;)&#10;&#10;    // Retrofit &amp; Network&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.11.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.11.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#10;&#10;    // Room Database&#10;    implementation(&quot;androidx.room:room-paging:2.7.0&quot;)&#10;    implementation(&quot;androidx.room:room-runtime:2.7.0&quot;)&#10;    implementation(&quot;androidx.room:room-ktx:2.7.0&quot;)&#10;    ksp(&quot;androidx.room:room-compiler:2.7.0&quot;)&#10;&#10;    // Paging&#10;    implementation(&quot;androidx.paging:paging-runtime-ktx:3.3.6&quot;)&#10;&#10;    // Image Loading&#10;    implementation(&quot;io.coil-kt:coil:2.7.0&quot;)&#10;    implementation(&quot;com.github.bumptech.glide:glide:4.16.0&quot;)&#10;    kapt(&quot;com.github.bumptech.glide:compiler:4.16.0&quot;)&#10;&#10;    // Dependency Injection&#10;    implementation(&quot;io.insert-koin:koin-android:4.1.0&quot;)&#10;&#10;    // Swipe To Refresh&#10;    implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;)&#10;&#10;    // Testing&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;}" />
              <option name="updatedContent" value="import java.util.Properties&#13;&#10;&#13;&#10;plugins {&#13;&#10;    alias(libs.plugins.android.application)&#13;&#10;    alias(libs.plugins.kotlin.android)&#13;&#10;    // Kotlin Kapt plugin&#13;&#10;    id(&quot;kotlin-kapt&quot;)&#13;&#10;    // Kotlin Symbol Processing plugin&#13;&#10;    id(&quot;com.google.devtools.ksp&quot;)&#13;&#10;    // Safe args plugin Kotlin-Only&#13;&#10;    id(&quot;androidx.navigation.safeargs.kotlin&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;// Load secrets.properties file&#13;&#10;val secretPropertiesFile = rootProject.file(&quot;secrets.properties&quot;) // Fixed path to the correct location&#13;&#10;val secretsProperties = Properties()&#13;&#10;if (secretPropertiesFile.exists())&#13;&#10;    secretsProperties.load(secretPropertiesFile.inputStream())&#13;&#10;else    // If the secrets.properties file does not exist, log a warning&#13;&#10;    println(&quot;Warning!!: secrets.properties file not found. Using empty properties.&quot;)&#13;&#10;&#13;&#10;android {&#13;&#10;    namespace = &quot;com.ragdoll.photogalleryapp&quot;&#13;&#10;    compileSdk = 35&#13;&#10;&#13;&#10;    defaultConfig {&#13;&#10;        applicationId = &quot;com.ragdoll.photogalleryapp&quot;&#13;&#10;        minSdk = 26&#13;&#10;        targetSdk = 35&#13;&#10;        versionCode = 1&#13;&#10;        versionName = &quot;1.0&quot;&#13;&#10;&#13;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#13;&#10;&#13;&#10;        // Access the property&#13;&#10;        val pexelsApiKey = secretsProperties.getProperty(&quot;PEXELS_API_KEY&quot;)&#13;&#10;            ?: &quot;&quot; // Default to empty string if not found&#13;&#10;        buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKey\&quot;&quot;)&#13;&#10;&#13;&#10;    }&#13;&#10;&#13;&#10;    buildTypes {&#13;&#10;        debug {&#13;&#10;            // Debug-specific configurations&#13;&#10;            // You can also define it per build type if needed&#13;&#10;            // val pexelsApiKeyDebug = secretsProperties.getProperty(&quot;PEXELS_API_KEY_DEBUG&quot;) ?: pexelsApiKey&#13;&#10;            // resValue(&quot;string&quot;, &quot;pexels_api_key&quot;, &quot;\&quot;$pexelsApiKeyDebug\&quot;&quot;) // Using resValue&#13;&#10;            // buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKeyDebug\&quot;&quot;)  // Using buildConfigField&#13;&#10;        }&#13;&#10;        release {&#13;&#10;            isMinifyEnabled = false&#13;&#10;            proguardFiles(&#13;&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#13;&#10;                &quot;proguard-rules.pro&quot;&#13;&#10;            )&#13;&#10;            // For release, you might also want to ensure the API key is set&#13;&#10;            // val pexelsApiKeyRelease = secretsProperties.getProperty(&quot;PEXELS_API_KEY_RELEASE&quot;) ?: pexelsApiKey&#13;&#10;            // buildConfigField(&quot;String&quot;, &quot;PEXELS_API_KEY&quot;, &quot;\&quot;$pexelsApiKeyRelease\&quot;&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    compileOptions {&#13;&#10;        sourceCompatibility = JavaVersion.VERSION_11&#13;&#10;        targetCompatibility = JavaVersion.VERSION_11&#13;&#10;    }&#13;&#10;    kotlinOptions {&#13;&#10;        jvmTarget = &quot;11&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    buildFeatures {&#13;&#10;        viewBinding = true&#13;&#10;        dataBinding = true&#13;&#10;        buildConfig = true&#13;&#10;    }&#13;&#10;&#13;&#10;}&#13;&#10;&#13;&#10;dependencies {&#13;&#10;    // Core&#13;&#10;    implementation(libs.androidx.core.ktx)&#13;&#10;    implementation(libs.androidx.appcompat)&#13;&#10;    implementation(libs.material)&#13;&#10;    implementation(libs.androidx.activity)&#13;&#10;    implementation(libs.androidx.constraintlayout)&#13;&#10;&#13;&#10;    // Lifecycle &amp; ViewModel&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.8.7&quot;)&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.8.7&quot;)&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-runtime-ktx:2.8.7&quot;)&#13;&#10;&#13;&#10;    // Navigation&#13;&#10;    implementation(&quot;androidx.navigation:navigation-fragment-ktx:2.9.0&quot;)&#13;&#10;    implementation(&quot;androidx.navigation:navigation-ui-ktx:2.9.0&quot;)&#13;&#10;&#13;&#10;    // Retrofit &amp; Network&#13;&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.11.0&quot;)&#13;&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.11.0&quot;)&#13;&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;)&#13;&#10;&#13;&#10;    // Room Database&#13;&#10;    implementation(&quot;androidx.room:room-paging:2.7.0&quot;)&#13;&#10;    implementation(&quot;androidx.room:room-runtime:2.7.0&quot;)&#13;&#10;    implementation(&quot;androidx.room:room-ktx:2.7.0&quot;)&#13;&#10;    ksp(&quot;androidx.room:room-compiler:2.7.0&quot;)&#13;&#10;&#13;&#10;    // Paging&#13;&#10;    implementation(&quot;androidx.paging:paging-runtime-ktx:3.3.6&quot;)&#13;&#10;&#13;&#10;    // Image Loading&#13;&#10;    implementation(&quot;io.coil-kt:coil:2.7.0&quot;)&#13;&#10;    implementation(&quot;com.github.bumptech.glide:glide:4.16.0&quot;)&#13;&#10;    kapt(&quot;com.github.bumptech.glide:compiler:4.16.0&quot;)&#13;&#10;&#13;&#10;    // Dependency Injection&#13;&#10;    implementation(&quot;io.insert-koin:koin-android:4.1.0&quot;)&#13;&#10;&#13;&#10;    // Swipe To Refresh&#13;&#10;    implementation(&quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;)&#13;&#10;&#13;&#10;    // Testing&#13;&#10;    testImplementation(libs.junit)&#13;&#10;    androidTestImplementation(libs.androidx.junit)&#13;&#10;    androidTestImplementation(libs.androidx.espresso.core)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/dao/RemoteKeysDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/dao/RemoteKeysDao.kt" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.dao&#10;&#10;import androidx.room.Dao&#10;import androidx.room.Insert&#10;import androidx.room.OnConflictStrategy&#10;import androidx.room.Query&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;&#10;/**&#10; * Data Access Object for the remote_keys table.&#10; * Provides methods to store and retrieve pagination keys.&#10; */&#10;@Dao&#10;interface RemoteKeysDao {&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertAll(remoteKeys: List&lt;RemoteKeys&gt;)&#10;&#10;    @Query(&quot;SELECT * FROM remote_keys WHERE photoId = :photoId&quot;)&#10;    suspend fun getRemoteKeysById(photoId: Int): RemoteKeys?&#10;&#10;    @Query(&quot;DELETE FROM remote_keys&quot;)&#10;    suspend fun clearRemoteKeys()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/database/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/database/AppDatabase.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.local.database&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.ragdoll.photogalleryapp.data.local.dao.PhotoDao&#10;import com.ragdoll.photogalleryapp.data.local.dao.RemoteKeysDao&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;&#10;@Database(entities = [PhotoEntity::class, RemoteKeys::class], version = 1, exportSchema = false)&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun photoDao(): PhotoDao&#10;    abstract fun remoteKeysDao(): RemoteKeysDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;        const val DATABASE_NAME = &quot;photo_database&quot;&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val newInstance = Room&#10;                    .databaseBuilder(context, AppDatabase::class.java, DATABASE_NAME)&#10;                    .allowMainThreadQueries()&#10;                    .build()&#10;                INSTANCE = newInstance&#10;                newInstance&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.database&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import com.ragdoll.photogalleryapp.data.local.dao.PhotoDao&#10;import com.ragdoll.photogalleryapp.data.local.dao.RemoteKeysDao&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;&#10;@Database(entities = [PhotoEntity::class, RemoteKeys::class], version = 2, exportSchema = false)&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun photoDao(): PhotoDao&#10;    abstract fun remoteKeysDao(): RemoteKeysDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;        const val DATABASE_NAME = &quot;photo_database&quot;&#10;        fun getInstance(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val newInstance = Room&#10;                    .databaseBuilder(context, AppDatabase::class.java, DATABASE_NAME)&#10;                    .fallbackToDestructiveMigration() // Add this to handle schema changes by recreating the database&#10;                    .allowMainThreadQueries()&#10;                    .build()&#10;                INSTANCE = newInstance&#10;                newInstance&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/entity/RemoteKeys.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/entity/RemoteKeys.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.local.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Entity class that stores pagination keys for each photo.&#10; * This helps the RemoteMediator know which pages have been loaded before&#10; * and which page to load next.&#10; */&#10;@Entity(tableName = &quot;remote_keys&quot;)&#10;data class RemoteKeys(&#10;    @PrimaryKey val photoId: Int,&#10;    val prevPage: Int?,&#10;    val currentPage: Int,&#10;    val nextPage: Int?&#10;)" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Entity class that stores pagination keys for each photo.&#10; * This helps the RemoteMediator know which pages have been loaded before&#10; * and which page to load next.&#10; */&#10;@Entity(tableName = &quot;remote_keys&quot;)&#10;data class RemoteKeys(&#10;    @PrimaryKey val photoId: Int,&#10;    val prevPage: Int?,&#10;    val currentPage: Int,&#10;    val nextPage: Int?&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#10;&#10;import android.util.Log&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import kotlinx.coroutines.flow.first&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class PhotoRemoteMediator(&#10;    private val api: PexelsApi,&#10;    val db: AppDatabase,&#10;    val networkMonitor: NetworkMonitor&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#10;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#10;    val photoDao = db.photoDao()&#10;    val remoteKeysDao = db.remoteKeysDao()&#10;&#10;    override suspend fun initialize(): InitializeAction {&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#10;        return if (isOnline)&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#10;            }&#10;        else&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#10;            }&#10;    }&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#10;    ): MediatorResult {&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#10;&#10;        // Check network connectivity first&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#10;&#10;        if (!isOnline) {&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#10;        }&#10;&#10;        return try {&#10;            // Calculate the page number based on the load type&#10;            val page = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#10;                    1&#10;                }&#10;&#10;                LoadType.PREPEND -&gt; {&#10;                    Log.d(TAG, &quot;load: PREPEND, no need to load more data at the beginning&quot;)&#10;                    return MediatorResult.Success(endOfPaginationReached = true)&#10;                }&#10;&#10;                LoadType.APPEND -&gt; {&#10;                    // Get the last remote key from the database&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    &#10;                    // If remoteKeys is null, it means we've reached the end of pagination&#10;                    if (remoteKeys == null) {&#10;                        Log.d(TAG, &quot;load: APPEND but no remote keys, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;                    &#10;                    val nextPage = remoteKeys.nextPage&#10;                    if (nextPage == null) {&#10;                        Log.d(TAG, &quot;load: APPEND but nextPage is null, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;                    &#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#10;                    nextPage&#10;                }&#10;            }&#10;&#10;            // Fetch data from the API with proper page size&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#10;            Log.d(TAG, &quot;load: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#10;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#10;            Log.d(TAG, &quot;load: API response received, photos count: ${response.photos.size}&quot;)&#10;&#10;            if (response.photos.isNotEmpty()) {&#10;                Log.v(TAG, &quot;load: First photo in response: id=${response.photos.first().id}, photographer=${response.photos.first().photographer}&quot;)&#10;                Log.v(TAG, &quot;load: Last photo in response: id=${response.photos.last().id}, photographer=${response.photos.last().photographer}&quot;)&#10;            }&#10;&#10;            // Calculate whether we've reached the end of pagination&#10;            val endOfPaginationReached = response.photos.isEmpty()&#10;            &#10;            // Calculate next page number&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#10;            &#10;            // Handle database transaction&#10;            Log.d(TAG, &quot;load: Starting database transaction&quot;)&#10;            db.withTransaction {&#10;                // If refreshing, clear the existing data&#10;                if (loadType == LoadType.REFRESH) {&#10;                    Log.d(TAG, &quot;load: REFRESH mode, clearing existing data&quot;)&#10;                    remoteKeysDao.clearRemoteKeys()&#10;                    photoDao.clearAll()&#10;                }&#10;&#10;                // Convert API responses to entities and insert them&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#10;                Log.d(TAG, &quot;load: Converted ${photoEntities.size} API responses to entities&quot;)&#10;                &#10;                // Create and insert remote keys&#10;                val keys = photoEntities.map { photo -&gt;&#10;                    RemoteKeys(&#10;                        photoId = photo.id,&#10;                        prevPage = prevPage,&#10;                        currentPage = page,&#10;                        nextPage = nextPage&#10;                    )&#10;                }&#10;                &#10;                // Insert keys and photos&#10;                if (keys.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;load: Inserting ${keys.size} remote keys into database&quot;)&#10;                    remoteKeysDao.insertAll(keys)&#10;                }&#10;                &#10;                if (photoEntities.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;load: Inserting ${photoEntities.size} photos into database&quot;)&#10;                    photoDao.insertALll(photoEntities)&#10;                    Log.d(TAG, &quot;load: Successfully inserted photos into database&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;load: No photos to insert into database&quot;)&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;load: End of pagination reached: $endOfPaginationReached&quot;)&#10;            MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#10;            MediatorResult.Error(e)&#10;        }&#10;    }&#10;    &#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the last page with data&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#10;        &#10;        // Get the last item from that page&#10;        val lastItem = lastPage?.data?.lastOrNull()&#10;        &#10;        // Return the remote keys associated with that item&#10;        return lastItem?.let { photo -&gt;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#10;&#10;import android.util.Log&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import kotlinx.coroutines.flow.first&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class PhotoRemoteMediator(&#10;    private val api: PexelsApi,&#10;    val db: AppDatabase,&#10;    val networkMonitor: NetworkMonitor&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#10;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#10;    val photoDao = db.photoDao()&#10;    val remoteKeysDao = db.remoteKeysDao()&#10;&#10;    override suspend fun initialize(): InitializeAction {&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#10;        return if (isOnline)&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#10;            }&#10;        else&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#10;            }&#10;    }&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#10;    ): MediatorResult {&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#10;&#10;        // Check network connectivity first&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#10;&#10;        if (!isOnline) {&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#10;        }&#10;&#10;        return try {&#10;            // Calculate the page number based on the load type&#10;            val page = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#10;                    1&#10;                }&#10;&#10;                LoadType.PREPEND -&gt; {&#10;                    Log.d(TAG, &quot;load: PREPEND, no need to load more data at the beginning&quot;)&#10;                    return MediatorResult.Success(endOfPaginationReached = true)&#10;                }&#10;&#10;                LoadType.APPEND -&gt; {&#10;                    // Get the last remote key from the database&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    &#10;                    // If remoteKeys is null, it means we've reached the end of pagination&#10;                    if (remoteKeys == null) {&#10;                        Log.d(TAG, &quot;load: APPEND but no remote keys, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;                    &#10;                    val nextPage = remoteKeys.nextPage&#10;                    if (nextPage == null) {&#10;                        Log.d(TAG, &quot;load: APPEND but nextPage is null, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;                    &#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#10;                    nextPage&#10;                }&#10;            }&#10;&#10;            // Fetch data from the API with proper page size&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#10;            Log.d(TAG, &quot;load: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#10;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#10;            Log.d(TAG, &quot;load: API response received, photos count: ${response.photos.size}&quot;)&#10;&#10;            if (response.photos.isNotEmpty()) {&#10;                Log.v(TAG, &quot;load: First photo in response: id=${response.photos.first().id}, photographer=${response.photos.first().photographer}&quot;)&#10;                Log.v(TAG, &quot;load: Last photo in response: id=${response.photos.last().id}, photographer=${response.photos.last().photographer}&quot;)&#10;            }&#10;&#10;            // Calculate whether we've reached the end of pagination&#10;            val endOfPaginationReached = response.photos.isEmpty()&#10;            &#10;            // Calculate next page number&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#10;            &#10;            // Handle database transaction&#10;            Log.d(TAG, &quot;load: Starting database transaction&quot;)&#10;            db.withTransaction {&#10;                // If refreshing, clear the existing data&#10;                if (loadType == LoadType.REFRESH) {&#10;                    Log.d(TAG, &quot;load: REFRESH mode, clearing existing data&quot;)&#10;                    remoteKeysDao.clearRemoteKeys()&#10;                    photoDao.clearAll()&#10;                }&#10;&#10;                // Convert API responses to entities and insert them&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#10;                Log.d(TAG, &quot;load: Converted ${photoEntities.size} API responses to entities&quot;)&#10;                &#10;                // Create and insert remote keys&#10;                val keys = photoEntities.map { photo -&gt;&#10;                    RemoteKeys(&#10;                        photoId = photo.id,&#10;                        prevPage = prevPage,&#10;                        currentPage = page,&#10;                        nextPage = nextPage&#10;                    )&#10;                }&#10;                &#10;                // Insert keys and photos&#10;                if (keys.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;load: Inserting ${keys.size} remote keys into database&quot;)&#10;                    remoteKeysDao.insertAll(keys)&#10;                }&#10;                &#10;                if (photoEntities.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;load: Inserting ${photoEntities.size} photos into database&quot;)&#10;                    photoDao.insertALll(photoEntities)&#10;                    Log.d(TAG, &quot;load: Successfully inserted photos into database&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;load: No photos to insert into database&quot;)&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;load: End of pagination reached: $endOfPaginationReached&quot;)&#10;            MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#10;            MediatorResult.Error(e)&#10;        }&#10;    }&#10;    &#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the last page with data&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#10;        &#10;        // Get the last item from that page&#10;        val lastItem = lastPage?.data?.lastOrNull()&#10;        &#10;        // Return the remote keys associated with that item&#10;        return lastItem?.let { photo -&gt;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/repository/PhotoRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/repository/PhotoRepositoryImpl.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.repository&#10;&#10;import android.util.Log&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.Pager&#10;import androidx.paging.PagingConfig&#10;import androidx.paging.PagingData&#10;import androidx.paging.map&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#10;import com.ragdoll.photogalleryapp.data.local.mediator.PhotoRemoteMediator&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.domain.model.Photo&#10;import com.ragdoll.photogalleryapp.domain.repository.PhotoRepository&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.conflate&#10;import kotlinx.coroutines.flow.map&#10;import kotlinx.coroutines.flow.onEach&#10;&#10;class PhotoRepositoryImpl(&#10;    private val api: PexelsApi,&#10;    private val db: AppDatabase,&#10;    private val networkMonitor: NetworkMonitor,&#10;) : PhotoRepository {&#10;    &#10;    private val TAG = &quot;PhotoRepository&quot;&#10;    &#10;    // Expose network state from the repository&#10;    override val networkState: Flow&lt;Boolean&gt; = networkMonitor.isOnline&#10;        .onEach { isOnline -&gt; Log.d(TAG, &quot;Network state changed: isOnline = $isOnline&quot;) }&#10;    &#10;    @OptIn(ExperimentalPagingApi::class)&#10;    override fun getPhotos(): Flow&lt;PagingData&lt;Photo&gt;&gt; {&#10;        Log.d(TAG, &quot;getPhotos: Creating paging flow&quot;)&#10;        // Create a mediator that's aware of network status&#10;        val remoteMediator = PhotoRemoteMediator(api, db, networkMonitor)&#10;        &#10;        return Pager(&#10;            config = PagingConfig(&#10;                pageSize = NETWORK_PAGE_SIZE,&#10;                prefetchDistance = NETWORK_PAGE_SIZE / 2,&#10;                enablePlaceholders = false,&#10;                initialLoadSize = NETWORK_PAGE_SIZE * 2&#10;            ),&#10;            remoteMediator = remoteMediator,&#10;            pagingSourceFactory = { &#10;                Log.d(TAG, &quot;Creating paging source from database&quot;)&#10;                db.photoDao().getPagingSource() &#10;            }&#10;        ).flow.map { pagingData -&gt;&#10;            Log.d(TAG, &quot;Received paging data, mapping to domain models&quot;)&#10;            pagingData.map { photoEntity -&gt;&#10;                PhotoMapper.mapToDomain(photoEntity).also { photo -&gt;&#10;                    Log.v(TAG, &quot;Mapped photo: id=${photo.id}, photographer=${photo.photographer}&quot;)&#10;                }&#10;            }&#10;        }&#10;        .onEach { pagingData -&gt;&#10;            Log.d(TAG, &quot;Emitting PagingData to UI&quot;)&#10;        }&#10;        .conflate() // Use conflate to ensure we only process the latest data&#10;    }&#10;&#10;    override suspend fun getPhotoById(id: Int): Photo? {&#10;        Log.d(TAG, &quot;getPhotoById: Fetching photo with id=$id&quot;)&#10;        return db.photoDao().getPhotoById(id)?.let {&#10;            Log.d(TAG, &quot;getPhotoById: Found photo in database, mapping to domain model&quot;)&#10;            PhotoMapper.mapToDomain(it)&#10;        } ?: run {&#10;            Log.w(TAG, &quot;getPhotoById: Photo with id=$id not found in database&quot;)&#10;            null&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        const val NETWORK_PAGE_SIZE = 20&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.repository&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import androidx.paging.ExperimentalPagingApi&#13;&#10;import androidx.paging.Pager&#13;&#10;import androidx.paging.PagingConfig&#13;&#10;import androidx.paging.PagingData&#13;&#10;import androidx.paging.map&#13;&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#13;&#10;import com.ragdoll.photogalleryapp.data.local.mediator.PhotoRemoteMediator&#13;&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#13;&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#13;&#10;import com.ragdoll.photogalleryapp.domain.model.Photo&#13;&#10;import com.ragdoll.photogalleryapp.domain.repository.PhotoRepository&#13;&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#13;&#10;import kotlinx.coroutines.flow.Flow&#13;&#10;import kotlinx.coroutines.flow.conflate&#13;&#10;import kotlinx.coroutines.flow.map&#13;&#10;import kotlinx.coroutines.flow.onEach&#13;&#10;&#13;&#10;class PhotoRepositoryImpl(&#13;&#10;    private val api: PexelsApi,&#13;&#10;    private val db: AppDatabase,&#13;&#10;    private val networkMonitor: NetworkMonitor,&#13;&#10;) : PhotoRepository {&#13;&#10;    &#13;&#10;    private val TAG = &quot;PhotoRepository&quot;&#13;&#10;    &#13;&#10;    // Expose network state from the repository&#13;&#10;    override val networkState: Flow&lt;Boolean&gt; = networkMonitor.isOnline&#13;&#10;        .onEach { isOnline -&gt; Log.d(TAG, &quot;Network state changed: isOnline = $isOnline&quot;) }&#13;&#10;    &#13;&#10;    @OptIn(ExperimentalPagingApi::class)&#13;&#10;    override fun getPhotos(): Flow&lt;PagingData&lt;Photo&gt;&gt; {&#13;&#10;        Log.d(TAG, &quot;getPhotos: Creating paging flow&quot;)&#13;&#10;        // Create a mediator that's aware of network status&#13;&#10;        val remoteMediator = PhotoRemoteMediator(api, db, networkMonitor)&#13;&#10;        &#13;&#10;        return Pager(&#13;&#10;            config = PagingConfig(&#13;&#10;                pageSize = NETWORK_PAGE_SIZE,&#13;&#10;                prefetchDistance = NETWORK_PAGE_SIZE / 2,&#13;&#10;                enablePlaceholders = false,&#13;&#10;                initialLoadSize = NETWORK_PAGE_SIZE * 2&#13;&#10;            ),&#13;&#10;            remoteMediator = remoteMediator,&#13;&#10;            pagingSourceFactory = { &#13;&#10;                Log.d(TAG, &quot;Creating paging source from database&quot;)&#13;&#10;                db.photoDao().getPagingSource() &#13;&#10;            }&#13;&#10;        ).flow.map { pagingData -&gt;&#13;&#10;            Log.d(TAG, &quot;Received paging data, mapping to domain models&quot;)&#13;&#10;            pagingData.map { photoEntity -&gt;&#13;&#10;                PhotoMapper.mapToDomain(photoEntity).also { photo -&gt;&#13;&#10;                    Log.v(TAG, &quot;Mapped photo: id=${photo.id}, photographer=${photo.photographer}&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        .onEach { pagingData -&gt;&#13;&#10;            Log.d(TAG, &quot;Emitting PagingData to UI&quot;)&#13;&#10;        }&#13;&#10;        .conflate() // Use conflate to ensure we only process the latest data&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun getPhotoById(id: Int): Photo? {&#13;&#10;        Log.d(TAG, &quot;getPhotoById: Fetching photo with id=$id&quot;)&#13;&#10;        return db.photoDao().getPhotoById(id)?.let {&#13;&#10;            Log.d(TAG, &quot;getPhotoById: Found photo in database, mapping to domain model&quot;)&#13;&#10;            PhotoMapper.mapToDomain(it)&#13;&#10;        } ?: run {&#13;&#10;            Log.w(TAG, &quot;getPhotoById: Photo with id=$id not found in database&quot;)&#13;&#10;            null&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        const val NETWORK_PAGE_SIZE = 20&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/di/AppModule.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.di&#10;&#10;import android.content.Context&#10;import android.net.ConnectivityManager&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl&#10;import com.ragdoll.photogalleryapp.domain.repository.PhotoRepository&#10;import com.ragdoll.photogalleryapp.domain.usecase.GetPhotosUseCase&#10;import com.ragdoll.photogalleryapp.presentation.common.ConnectivityManagerNetworkMonitor&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import org.koin.android.ext.koin.androidContext&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.dsl.module&#10;&#10;&#10;/**&#10; * Main application module that defines all dependencies for the app&#10; */&#10;val appModule = module {&#10;    // ViewModels&#10;    // Example: viewModel { YourViewModel(get()) }&#10;    viewModel {&#10;        PhotosViewModel(&#10;            get(),&#10;            get(),&#10;            get(),&#10;        )&#10;    }&#10;//    viewModelFactory { PhotosViewModelFactory(get(), get(), get()) }&#10;&#10;    // Use Cases&#10;    // Example: single { YourUseCase(get()) }&#10;    single {&#10;        GetPhotosUseCase(get())&#10;    }&#10;&#10;    // Repositories&#10;    // Example: single { YourRepository(get()) }&#10;    single {&#10;        PhotoRepositoryImpl(&#10;            get(),&#10;            get(),&#10;            get(),&#10;        ) as PhotoRepository&#10;    }&#10;&#10;    // Data Sources&#10;    // Example: single { YourRemoteDataSource(get()) }&#10;&#10;    // API Services&#10;    // Example: single { createApiService&lt;YourApiService&gt;(get()) }&#10;&#10;&#10;    // Database and DAOs&#10;    // Example: single { get&lt;AppDatabase&gt;().yourDao() }&#10;&#10;    // Utilities and other dependencies&#10;    // Example: single { YourUtility() }&#10;&#10;    // NetworkMonitor dependency&#10;    single&lt;NetworkMonitor&gt; {&#10;        ConnectivityManagerNetworkMonitor(androidContext())&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.di&#10;&#10;import android.content.Context&#10;import android.net.ConnectivityManager&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl&#10;import com.ragdoll.photogalleryapp.domain.repository.PhotoRepository&#10;import com.ragdoll.photogalleryapp.domain.usecase.GetPhotosUseCase&#10;import com.ragdoll.photogalleryapp.presentation.common.ConnectivityManagerNetworkMonitor&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import org.koin.android.ext.koin.androidContext&#10;import org.koin.core.module.dsl.viewModel&#10;import org.koin.dsl.module&#10;&#10;&#10;/**&#10; * Main application module that defines all dependencies for the app&#10; */&#10;val appModule = module {&#10;    // ViewModels&#10;    // Example: viewModel { YourViewModel(get()) }&#10;    viewModel {&#10;        PhotosViewModel(&#10;            get(),&#10;            get(),&#10;            get(),&#10;        )&#10;    }&#10;//    viewModelFactory { PhotosViewModelFactory(get(), get(), get()) }&#10;&#10;    // Use Cases&#10;    // Example: single { YourUseCase(get()) }&#10;    single {&#10;        GetPhotosUseCase(get())&#10;    }&#10;&#10;    // Repositories&#10;    // Example: single { YourRepository(get()) }&#10;    single {&#10;        PhotoRepositoryImpl(&#10;            get(),&#10;            get(),&#10;            get(),&#10;        ) as PhotoRepository&#10;    }&#10;&#10;    // Data Sources&#10;    // Example: single { YourRemoteDataSource(get()) }&#10;&#10;    // API Services&#10;    // Example: single { createApiService&lt;YourApiService&gt;(get()) }&#10;&#10;&#10;    // Database and DAOs&#10;    // Example: single { get&lt;AppDatabase&gt;().yourDao() }&#10;&#10;    // Utilities and other dependencies&#10;    // Example: single { YourUtility() }&#10;    &#10;    // NetworkMonitor dependency&#10;    single&lt;NetworkMonitor&gt; {&#10;        ConnectivityManagerNetworkMonitor(androidContext())&#10;    }&#10;    &#10;    // System services&#10;    single { &#10;        androidContext().getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager &#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/presentation/ui/fragment/HomeFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/presentation/ui/fragment/HomeFragment.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.presentation.ui.fragment&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.paging.LoadState&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager&#10;import com.ragdoll.photogalleryapp.R&#10;import com.ragdoll.photogalleryapp.databinding.FragmentHomeBinding&#10;import com.ragdoll.photogalleryapp.presentation.adapter.PhotoAdapter&#10;import com.ragdoll.photogalleryapp.presentation.ui.activity.MainActivity&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.distinctUntilChanged&#10;import kotlinx.coroutines.launch&#10;import org.koin.androidx.viewmodel.ext.android.viewModel&#10;&#10;// 8 paging&#10;class HomeFragment : Fragment() {&#10;    private lateinit var binding: FragmentHomeBinding&#10;    private lateinit var viewModel: PhotosViewModel&#10;    private val photoAdapter = PhotoAdapter()&#10;    private val TAG = &quot;HomeFragment&quot;&#10;&#10;    // Track the previous network state to detect changes&#10;    private var previousNetworkState = false&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        viewModel = (activity as MainActivity).viewModel&#10;        Log.d(TAG, &quot;onViewCreated: ViewModel initialized&quot;)&#10;&#10;        initRecyclerView()&#10;        observeLoadStates() // Add load state observer&#10;        observePhotos()&#10;        observeNetworkState()&#10;        setupPhotoClickListener()&#10;&#10;        // Initially show loading, but this will be controlled by the load state observer&#10;        binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun initRecyclerView() = binding.photosRV.apply {&#10;        adapter = photoAdapter&#10;        layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        Log.d(TAG, &quot;initRecyclerView: RecyclerView initialized with adapter&quot;)&#10;    }&#10;&#10;    // Add a new function to observe adapter load states&#10;    private fun observeLoadStates() {&#10;        lifecycleScope.launch {&#10;            photoAdapter.loadStateFlow&#10;                .distinctUntilChanged()&#10;                .collect { loadStates -&gt;&#10;                    Log.d(TAG, &quot;observeLoadStates: Load state changed: ${loadStates.refresh}&quot;)&#10;&#10;                    // Handle loading state&#10;                    when (loadStates.refresh) {&#10;                        is LoadState.Loading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;                        }&#10;                        is LoadState.Error -&gt; {&#10;                            val error = (loadStates.refresh as LoadState.Error).error&#10;                            Log.e(TAG, &quot;observeLoadStates: Error loading data&quot;, error)&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;                            if (!viewModel.isOnline.value) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_internet_connection)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                                binding.photosRV.visibility = View.GONE&#10;                            }&#10;                        }&#10;                        is LoadState.NotLoading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;                            if (photoAdapter.itemCount == 0) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_photos_available)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                            } else {&#10;                                binding.noPhotosTv.visibility = View.GONE&#10;                                binding.photosRV.visibility = View.VISIBLE&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun observePhotos() {&#10;        Log.d(TAG, &quot;observePhotos: Starting to observe photos flow&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.photos.collectLatest { pagingData -&gt;&#10;                Log.d(TAG, &quot;observePhotos: Received paging data&quot;)&#10;                photoAdapter.submitData(pagingData)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeNetworkState() {&#10;        Log.d(TAG, &quot;observeNetworkState: Starting to observe network state&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.isOnline.collect { isOnline -&gt;&#10;                Log.d(TAG, &quot;observeNetworkState: Network state changed, isOnline = $isOnline&quot;)&#10;                if (!isOnline &amp;&amp; photoAdapter.itemCount == 0) {&#10;                    binding.noPhotosTv.apply {&#10;                        text = getString(R.string.no_internet_connection)&#10;                        visibility = View.VISIBLE&#10;                    }&#10;                    binding.photosRV.visibility = View.GONE&#10;                } else if (isOnline) {&#10;                    binding.noPhotosTv.visibility = View.GONE&#10;                    binding.photosRV.visibility = View.VISIBLE&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupPhotoClickListener() {&#10;        photoAdapter.setOnItemClickListener { photo -&gt;&#10;            // Ensure loading indicator is hidden before navigation&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;            val bundle = Bundle().apply {&#10;                putString(&quot;photo_photographer&quot;, photo.photographer)&#10;                putString(&quot;photo_original_url&quot;, photo.src.original)&#10;                putString(&quot;photo_alt&quot;, photo.alt)&#10;            }&#10;            findNavController().navigate(&#10;                R.id.action_homeFragment_to_detailsFragment, bundle&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Ensure loading indicator is hidden when fragment is destroyed&#10;        if (::binding.isInitialized) {&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.presentation.ui.fragment&#10;&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.fragment.app.Fragment&#10;import androidx.lifecycle.lifecycleScope&#10;import androidx.navigation.fragment.findNavController&#10;import androidx.paging.LoadState&#10;import androidx.recyclerview.widget.StaggeredGridLayoutManager&#10;import com.ragdoll.photogalleryapp.R&#10;import com.ragdoll.photogalleryapp.databinding.FragmentHomeBinding&#10;import com.ragdoll.photogalleryapp.presentation.adapter.PhotoAdapter&#10;import com.ragdoll.photogalleryapp.presentation.ui.activity.MainActivity&#10;import com.ragdoll.photogalleryapp.presentation.viewmodel.PhotosViewModel&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.flow.distinctUntilChanged&#10;import kotlinx.coroutines.launch&#10;import org.koin.androidx.viewmodel.ext.android.viewModel&#10;&#10;// 8 paging&#10;class HomeFragment : Fragment() {&#10;    private lateinit var binding: FragmentHomeBinding&#10;    private lateinit var viewModel: PhotosViewModel&#10;    private val photoAdapter = PhotoAdapter()&#10;    private val TAG = &quot;HomeFragment&quot;&#10;&#10;    // Track the previous network state to detect changes&#10;    private var previousNetworkState = false&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?&#10;    ): View {&#10;        binding = FragmentHomeBinding.inflate(inflater, container, false)&#10;        return binding.root&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;        viewModel = (activity as MainActivity).viewModel&#10;        Log.d(TAG, &quot;onViewCreated: ViewModel initialized&quot;)&#10;&#10;        initRecyclerView()&#10;        observeLoadStates() // Add load state observer&#10;        observePhotos()&#10;        observeNetworkState()&#10;        setupPhotoClickListener()&#10;&#10;        // Initially show loading, but this will be controlled by the load state observer&#10;        binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;    }&#10;&#10;    private fun initRecyclerView() = binding.photosRV.apply {&#10;        adapter = photoAdapter&#10;        layoutManager = StaggeredGridLayoutManager(2, StaggeredGridLayoutManager.VERTICAL)&#10;        Log.d(TAG, &quot;initRecyclerView: RecyclerView initialized with adapter&quot;)&#10;    }&#10;&#10;    // Add a new function to observe adapter load states&#10;    private fun observeLoadStates() {&#10;        lifecycleScope.launch {&#10;            photoAdapter.loadStateFlow&#10;                .distinctUntilChanged()&#10;                .collect { loadStates -&gt;&#10;                    Log.d(TAG, &quot;observeLoadStates: Load state changed: ${loadStates.refresh}&quot;)&#10;&#10;                    // Handle loading state&#10;                    when (loadStates.refresh) {&#10;                        is LoadState.Loading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.VISIBLE&#10;                        }&#10;                        is LoadState.Error -&gt; {&#10;                            val error = (loadStates.refresh as LoadState.Error).error&#10;                            Log.e(TAG, &quot;observeLoadStates: Error loading data&quot;, error)&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;                            if (!viewModel.isOnline.value) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_internet_connection)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                                binding.photosRV.visibility = View.GONE&#10;                            }&#10;                        }&#10;                        is LoadState.NotLoading -&gt; {&#10;                            binding.loadingProgressIndicator.visibility = View.GONE&#10;                            if (photoAdapter.itemCount == 0) {&#10;                                binding.noPhotosTv.apply {&#10;                                    text = getString(R.string.no_photos_available)&#10;                                    visibility = View.VISIBLE&#10;                                }&#10;                            } else {&#10;                                binding.noPhotosTv.visibility = View.GONE&#10;                                binding.photosRV.visibility = View.VISIBLE&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun observePhotos() {&#10;        Log.d(TAG, &quot;observePhotos: Starting to observe photos flow&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.photos.collectLatest { pagingData -&gt;&#10;                Log.d(TAG, &quot;observePhotos: Received paging data&quot;)&#10;                photoAdapter.submitData(pagingData)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observeNetworkState() {&#10;        Log.d(TAG, &quot;observeNetworkState: Starting to observe network state&quot;)&#10;        lifecycleScope.launch {&#10;            viewModel.isOnline.collect { isOnline -&gt;&#10;                Log.d(TAG, &quot;observeNetworkState: Network state changed, isOnline = $isOnline&quot;)&#10;&#10;                // Handle the case when network becomes available (was offline, now online)&#10;                val networkBecameAvailable = !previousNetworkState &amp;&amp; isOnline&#10;                previousNetworkState = isOnline&#10;&#10;                if (!isOnline &amp;&amp; photoAdapter.itemCount == 0) {&#10;                    binding.noPhotosTv.apply {&#10;                        text = getString(R.string.no_internet_connection)&#10;                        visibility = View.VISIBLE&#10;                    }&#10;                    binding.photosRV.visibility = View.GONE&#10;                } else if (isOnline) {&#10;                    binding.noPhotosTv.visibility = View.GONE&#10;                    binding.photosRV.visibility = View.VISIBLE&#10;&#10;                    // If network just became available, trigger a refresh&#10;                    if (networkBecameAvailable) {&#10;                        Log.d(TAG, &quot;observeNetworkState: Network became available, refreshing data&quot;)&#10;                        photoAdapter.refresh()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupPhotoClickListener() {&#10;        photoAdapter.setOnItemClickListener { photo -&gt;&#10;            // Ensure loading indicator is hidden before navigation&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;&#10;            val bundle = Bundle().apply {&#10;                putString(&quot;photo_photographer&quot;, photo.photographer)&#10;                putString(&quot;photo_original_url&quot;, photo.src.original)&#10;                putString(&quot;photo_alt&quot;, photo.alt)&#10;            }&#10;            findNavController().navigate(&#10;                R.id.action_homeFragment_to_detailsFragment, bundle&#10;            )&#10;        }&#10;    }&#10;&#10;    override fun onDestroyView() {&#10;        super.onDestroyView()&#10;        // Ensure loading indicator is hidden when fragment is destroyed&#10;        if (::binding.isInitialized) {&#10;            binding.loadingProgressIndicator.visibility = View.GONE&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>