<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/ragdoll/photogalleryapp/data/local/mediator/PhotoRemoteMediator.kt" />
              <option name="originalContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#10;&#10;import android.util.Log&#10;import androidx.paging.ExperimentalPagingApi&#10;import androidx.paging.LoadType&#10;import androidx.paging.PagingState&#10;import androidx.paging.RemoteMediator&#10;import androidx.room.withTransaction&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#10;import kotlinx.coroutines.flow.first&#10;&#10;@OptIn(ExperimentalPagingApi::class)&#10;class PhotoRemoteMediator(&#10;    private val api: PexelsApi,&#10;    val db: AppDatabase,&#10;    val networkMonitor: NetworkMonitor&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#10;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#10;    val photoDao = db.photoDao()&#10;    val remoteKeysDao = db.remoteKeysDao()&#10;&#10;    override suspend fun initialize(): InitializeAction {&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#10;        return if (isOnline)&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#10;            }&#10;        else&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#10;            }&#10;    }&#10;&#10;    override suspend fun load(&#10;        loadType: LoadType,&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#10;    ): MediatorResult {&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#10;&#10;        // Check network connectivity first&#10;        val isOnline = networkMonitor.isOnline.first()&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#10;&#10;        if (!isOnline) {&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#10;        }&#10;&#10;        try {&#10;            // Calculate the page number based on the load type&#10;            val page = when (loadType) {&#10;                LoadType.REFRESH -&gt; {&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#10;                    1&#10;                }&#10;&#10;                LoadType.PREPEND -&gt; {&#10;                    // Get the remote key of the first item in the database&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#10;&#10;                    // If remoteKeys is null or prevPage is null, there's no more data to load at the beginning&#10;                    val prevPage = remoteKeys?.prevPage&#10;                    if (prevPage == null) {&#10;                        Log.d(TAG, &quot;load: PREPEND, no more data at beginning, remoteKeys=$remoteKeys&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;load: PREPEND, loading page $prevPage&quot;)&#10;                    prevPage&#10;                }&#10;&#10;                LoadType.APPEND -&gt; {&#10;                    Log.d(TAG, &quot;load: APPEND request initiated&quot;)&#10;&#10;                    // Get the remote key of the last item in the database&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#10;                    Log.d(TAG, &quot;load: APPEND got remoteKeys: $remoteKeys&quot;)&#10;&#10;                    if (remoteKeys == null) {&#10;                        // If there are no keys yet (empty DB), start with page 1&#10;                        // This handles the initial empty database case&#10;                        val nextPageFromEmpty = 1&#10;                        Log.d(TAG, &quot;load: APPEND no remoteKeys found, using default page=$nextPageFromEmpty&quot;)&#10;                        return loadAndSaveData(nextPageFromEmpty, loadType, state)&#10;                    }&#10;&#10;                    val nextPage = remoteKeys.nextPage&#10;                    if (nextPage == null) {&#10;                        Log.d(TAG, &quot;load: APPEND nextPage is null, we've reached the end&quot;)&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#10;                    }&#10;&#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#10;                    nextPage&#10;                }&#10;            }&#10;&#10;            return loadAndSaveData(page, loadType, state)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#10;            return MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun loadAndSaveData(page: Int, loadType: LoadType, state: PagingState&lt;Int, PhotoEntity&gt;): MediatorResult {&#10;        try {&#10;            // Fetch data from the API with proper page size&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#10;            Log.d(TAG, &quot;loadAndSaveData: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#10;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#10;            Log.d(TAG, &quot;loadAndSaveData: API response received, photos count: ${response.photos.size}&quot;)&#10;&#10;            if (response.photos.isNotEmpty()) {&#10;                Log.d(TAG, &quot;loadAndSaveData: First photo in response: id=${response.photos.first().id}&quot;)&#10;                Log.d(TAG, &quot;loadAndSaveData: Last photo in response: id=${response.photos.last().id}&quot;)&#10;            }&#10;&#10;            // Calculate whether we've reached the end of pagination&#10;            val endOfPaginationReached = response.photos.isEmpty()&#10;&#10;            // Calculate next and previous page numbers&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#10;&#10;            // Handle database transaction&#10;            Log.d(TAG, &quot;loadAndSaveData: Starting database transaction&quot;)&#10;            db.withTransaction {&#10;                // If refreshing, clear the existing data&#10;                if (loadType == LoadType.REFRESH) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: REFRESH mode, clearing existing data&quot;)&#10;                    remoteKeysDao.clearRemoteKeys()&#10;                    photoDao.clearAll()&#10;                }&#10;&#10;                // Convert API responses to entities&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#10;                Log.d(TAG, &quot;loadAndSaveData: Converted ${photoEntities.size} API responses to entities&quot;)&#10;&#10;                // Create and insert remote keys&#10;                val keys = photoEntities.map { photo -&gt;&#10;                    RemoteKeys(&#10;                        photoId = photo.id,&#10;                        prevPage = prevPage,&#10;                        currentPage = page,&#10;                        nextPage = nextPage&#10;                    )&#10;                }&#10;&#10;                // Insert keys and photos&#10;                if (keys.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${keys.size} remote keys into database&quot;)&#10;                    remoteKeysDao.insertAll(keys)&#10;                }&#10;&#10;                if (photoEntities.isNotEmpty()) {&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${photoEntities.size} photos into database&quot;)&#10;                    photoDao.insertALll(photoEntities)&#10;                    Log.d(TAG, &quot;loadAndSaveData: Successfully inserted photos into database&quot;)&#10;                } else {&#10;                    Log.w(TAG, &quot;loadAndSaveData: No photos to insert into database&quot;)&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;loadAndSaveData: End of pagination reached: $endOfPaginationReached&quot;)&#10;            return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;loadAndSaveData: Error loading data&quot;, e)&#10;            Log.e(TAG, &quot;loadAndSaveData: Error message: ${e.message}&quot;)&#10;            return MediatorResult.Error(e)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForFirstItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the first page with data&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#10;            ?.let { photo -&gt;&#10;                remoteKeysDao.getRemoteKeysById(photo.id)&#10;            }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // Get the last page with data&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#10;&#10;        // Get the last item from that page&#10;        val lastItem = lastPage?.data?.lastOrNull()&#10;&#10;        // Return the remote keys associated with that item&#10;        return lastItem?.let { photo -&gt;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#10;        }&#10;    }&#10;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#10;        // The paging library is trying to load data after the anchor position&#10;        // Get the item closest to the anchor position&#10;        return state.anchorPosition?.let { position -&gt;&#10;            state.closestItemToPosition(position)?.id?.let { id -&gt;&#10;                remoteKeysDao.getRemoteKeysById(id)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.ragdoll.photogalleryapp.data.local.mediator&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import androidx.paging.ExperimentalPagingApi&#13;&#10;import androidx.paging.LoadType&#13;&#10;import androidx.paging.PagingState&#13;&#10;import androidx.paging.RemoteMediator&#13;&#10;import androidx.room.withTransaction&#13;&#10;import com.ragdoll.photogalleryapp.data.local.database.AppDatabase&#13;&#10;import com.ragdoll.photogalleryapp.data.local.entity.PhotoEntity&#13;&#10;import com.ragdoll.photogalleryapp.data.local.entity.RemoteKeys&#13;&#10;import com.ragdoll.photogalleryapp.data.mapper.PhotoMapper&#13;&#10;import com.ragdoll.photogalleryapp.data.remote.api.PexelsApi&#13;&#10;import com.ragdoll.photogalleryapp.data.repository.PhotoRepositoryImpl.Companion.NETWORK_PAGE_SIZE&#13;&#10;import com.ragdoll.photogalleryapp.presentation.common.NetworkMonitor&#13;&#10;import kotlinx.coroutines.flow.first&#13;&#10;&#13;&#10;@OptIn(ExperimentalPagingApi::class)&#13;&#10;class PhotoRemoteMediator(&#13;&#10;    private val api: PexelsApi,&#13;&#10;    val db: AppDatabase,&#13;&#10;    val networkMonitor: NetworkMonitor&#13;&#10;) : RemoteMediator&lt;Int, PhotoEntity&gt;() {&#13;&#10;&#13;&#10;    private val TAG = &quot;PhotoRemoteMediator&quot;&#13;&#10;    val photoDao = db.photoDao()&#13;&#10;    val remoteKeysDao = db.remoteKeysDao()&#13;&#10;&#13;&#10;    override suspend fun initialize(): InitializeAction {&#13;&#10;        val isOnline = networkMonitor.isOnline.first()&#13;&#10;        Log.d(TAG, &quot;initialize: isOnline = $isOnline&quot;)&#13;&#10;        return if (isOnline)&#13;&#10;            InitializeAction.LAUNCH_INITIAL_REFRESH.also {&#13;&#10;                Log.d(TAG, &quot;initialize: LAUNCH_INITIAL_REFRESH&quot;)&#13;&#10;            }&#13;&#10;        else&#13;&#10;            InitializeAction.SKIP_INITIAL_REFRESH.also {&#13;&#10;                Log.d(TAG, &quot;initialize: SKIP_INITIAL_REFRESH - No internet connection&quot;)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun load(&#13;&#10;        loadType: LoadType,&#13;&#10;        state: PagingState&lt;Int, PhotoEntity&gt;&#13;&#10;    ): MediatorResult {&#13;&#10;        Log.d(TAG, &quot;load: loadType = $loadType, state pageSize = ${state.config.pageSize}&quot;)&#13;&#10;&#13;&#10;        // Check network connectivity first&#13;&#10;        val isOnline = networkMonitor.isOnline.first()&#13;&#10;        Log.d(TAG, &quot;load: isOnline = $isOnline&quot;)&#13;&#10;&#13;&#10;        if (!isOnline) {&#13;&#10;            Log.w(TAG, &quot;load: No internet connection, returning error&quot;)&#13;&#10;            return MediatorResult.Error(Exception(&quot;No internet connection&quot;))&#13;&#10;        }&#13;&#10;&#13;&#10;        try {&#13;&#10;            // Calculate the page number based on the load type&#13;&#10;            val page = when (loadType) {&#13;&#10;                LoadType.REFRESH -&gt; {&#13;&#10;                    Log.d(TAG, &quot;load: REFRESH, starting from page 1&quot;)&#13;&#10;                    1&#13;&#10;                }&#13;&#10;&#13;&#10;                LoadType.PREPEND -&gt; {&#13;&#10;                    // Get the remote key of the first item in the database&#13;&#10;                    val remoteKeys = getRemoteKeyForFirstItem(state)&#13;&#10;&#13;&#10;                    // If remoteKeys is null or prevPage is null, there's no more data to load at the beginning&#13;&#10;                    val prevPage = remoteKeys?.prevPage&#13;&#10;                    if (prevPage == null) {&#13;&#10;                        Log.d(TAG, &quot;load: PREPEND, no more data at beginning, remoteKeys=$remoteKeys&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;load: PREPEND, loading page $prevPage&quot;)&#13;&#10;                    prevPage&#13;&#10;                }&#13;&#10;&#13;&#10;                LoadType.APPEND -&gt; {&#13;&#10;                    Log.d(TAG, &quot;load: APPEND request initiated&quot;)&#13;&#10;&#13;&#10;                    // Get the remote key of the last item in the database&#13;&#10;                    val remoteKeys = getRemoteKeyForLastItem(state)&#13;&#10;                    Log.d(TAG, &quot;load: APPEND got remoteKeys: $remoteKeys&quot;)&#13;&#10;&#13;&#10;                    if (remoteKeys == null) {&#13;&#10;                        // If there are no keys yet (empty DB), start with page 1&#13;&#10;                        // This handles the initial empty database case&#13;&#10;                        val nextPageFromEmpty = 1&#13;&#10;                        Log.d(TAG, &quot;load: APPEND no remoteKeys found, using default page=$nextPageFromEmpty&quot;)&#13;&#10;                        return loadAndSaveData(nextPageFromEmpty, loadType, state)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    val nextPage = remoteKeys.nextPage&#13;&#10;                    if (nextPage == null) {&#13;&#10;                        Log.d(TAG, &quot;load: APPEND nextPage is null, we've reached the end&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = true)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Check if we've already loaded this page to prevent duplicate loads&#13;&#10;                    val lastLoadedPage = remoteKeys.currentPage&#13;&#10;                    if (nextPage == lastLoadedPage) {&#13;&#10;                        Log.d(TAG, &quot;load: APPEND skipping duplicate load of page $nextPage&quot;)&#13;&#10;                        return MediatorResult.Success(endOfPaginationReached = false)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;load: APPEND, loading page $nextPage&quot;)&#13;&#10;                    nextPage&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            return loadAndSaveData(page, loadType, state)&#13;&#10;&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;load: Error loading data&quot;, e)&#13;&#10;            Log.e(TAG, &quot;load: Error message: ${e.message}&quot;)&#13;&#10;            return MediatorResult.Error(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun loadAndSaveData(page: Int, loadType: LoadType, state: PagingState&lt;Int, PhotoEntity&gt;): MediatorResult {&#13;&#10;        try {&#13;&#10;            // Fetch data from the API with proper page size&#13;&#10;            val apiPageSize = state.config.pageSize.coerceAtMost(NETWORK_PAGE_SIZE)&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: Making API call to getCuratedPhotos(page=$page, perPage=$apiPageSize)&quot;)&#13;&#10;&#13;&#10;            val response = api.getCuratedPhotos(page = page, perPage = apiPageSize)&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: API response received, photos count: ${response.photos.size}&quot;)&#13;&#10;&#13;&#10;            if (response.photos.isNotEmpty()) {&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: First photo in response: id=${response.photos.first().id}&quot;)&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: Last photo in response: id=${response.photos.last().id}&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            // Calculate whether we've reached the end of pagination&#13;&#10;            val endOfPaginationReached = response.photos.isEmpty()&#13;&#10;&#13;&#10;            // Calculate next and previous page numbers&#13;&#10;            val nextPage = if (endOfPaginationReached) null else page + 1&#13;&#10;            val prevPage = if (page &gt; 1) page - 1 else null&#13;&#10;&#13;&#10;            // Handle database transaction&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: Starting database transaction&quot;)&#13;&#10;            db.withTransaction {&#13;&#10;                // If refreshing, clear the existing data&#13;&#10;                if (loadType == LoadType.REFRESH) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: REFRESH mode, clearing existing data&quot;)&#13;&#10;                    remoteKeysDao.clearRemoteKeys()&#13;&#10;                    photoDao.clearAll()&#13;&#10;                }&#13;&#10;&#13;&#10;                // Convert API responses to entities&#13;&#10;                val photoEntities = response.photos.map { PhotoMapper.mapToEntity(it) }&#13;&#10;                Log.d(TAG, &quot;loadAndSaveData: Converted ${photoEntities.size} API responses to entities&quot;)&#13;&#10;&#13;&#10;                // Create and insert remote keys&#13;&#10;                val keys = photoEntities.map { photo -&gt;&#13;&#10;                    RemoteKeys(&#13;&#10;                        photoId = photo.id,&#13;&#10;                        prevPage = prevPage,&#13;&#10;                        currentPage = page,&#13;&#10;                        nextPage = nextPage&#13;&#10;                    )&#13;&#10;                }&#13;&#10;&#13;&#10;                // Insert keys and photos&#13;&#10;                if (keys.isNotEmpty()) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${keys.size} remote keys into database&quot;)&#13;&#10;                    remoteKeysDao.insertAll(keys)&#13;&#10;                }&#13;&#10;&#13;&#10;                if (photoEntities.isNotEmpty()) {&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Inserting ${photoEntities.size} photos into database&quot;)&#13;&#10;                    photoDao.insertALll(photoEntities)&#13;&#10;                    Log.d(TAG, &quot;loadAndSaveData: Successfully inserted photos into database&quot;)&#13;&#10;                } else {&#13;&#10;                    Log.w(TAG, &quot;loadAndSaveData: No photos to insert into database&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            Log.d(TAG, &quot;loadAndSaveData: End of pagination reached: $endOfPaginationReached&quot;)&#13;&#10;            return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;loadAndSaveData: Error loading data&quot;, e)&#13;&#10;            Log.e(TAG, &quot;loadAndSaveData: Error message: ${e.message}&quot;)&#13;&#10;            return MediatorResult.Error(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyForFirstItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // Get the first page with data&#13;&#10;        return state.pages.firstOrNull { it.data.isNotEmpty() }?.data?.firstOrNull()&#13;&#10;            ?.let { photo -&gt;&#13;&#10;                remoteKeysDao.getRemoteKeysById(photo.id)&#13;&#10;            }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyForLastItem(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // Get the last page with data&#13;&#10;        val lastPage = state.pages.lastOrNull { it.data.isNotEmpty() }&#13;&#10;&#13;&#10;        // Get the last item from that page&#13;&#10;        val lastItem = lastPage?.data?.lastOrNull()&#13;&#10;&#13;&#10;        // Return the remote keys associated with that item&#13;&#10;        return lastItem?.let { photo -&gt;&#13;&#10;            remoteKeysDao.getRemoteKeysById(photo.id)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun getRemoteKeyClosestToCurrentPosition(state: PagingState&lt;Int, PhotoEntity&gt;): RemoteKeys? {&#13;&#10;        // The paging library is trying to load data after the anchor position&#13;&#10;        // Get the item closest to the anchor position&#13;&#10;        return state.anchorPosition?.let { position -&gt;&#13;&#10;            state.closestItemToPosition(position)?.id?.let { id -&gt;&#13;&#10;                remoteKeysDao.getRemoteKeysById(id)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>